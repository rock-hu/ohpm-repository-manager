"use strict";var t=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(i,o){function s(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))},e=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CryptoUtil=void 0;const r=require("../packages/crypto/base"),n=require("../packages/crypto"),i=require("../common/Constants"),o=e(require("path")),s=require("../packages/log"),a=require("./FsUtil"),c=require("crypto");class y{static getInstance(){return this.Instance||(this.Instance=new y,this.Instance.init()),this.Instance}init(){this.metaDir=o.default.join(i.Constants.DATA_DIR,i.Constants.KEY_DIR_NAME),this.metaNewDir=o.default.join(i.Constants.DATA_DIR,i.Constants.NEW_KEY_DIR_NAME)}static encrypt(t){return y.getInstance().encrypt(t)}static decrypt(e,r){return t(this,void 0,void 0,(function*(){const t=y.getInstance();return yield t.decrypt(e,r)}))}static getVersion(){return y.getInstance().getVersion()}encrypt(t){const e=new n.Crypto(this.metaDir);let i="";try{i=r.AesCryptUtil.encryptAesGcm(t,e.getEncWorkKey(),e.getRootKey())}catch(t){s.OhpmLazyLogger.error("fail to encrypt data: ",t.message)}finally{e.destroy()}return i}decrypt(e,i){return t(this,void 0,void 0,(function*(){const t=new n.Crypto(this.metaDir);let o,c="";try{if((yield a.FsUtil.exists(this.metaNewDir))&&(yield(0,n.validKey)(this.metaNewDir))&&(o=new n.Crypto(this.metaNewDir)),i&&t.getCryptoVersion()!==i){if(!o||o.getCryptoVersion()!==i)throw new Error("valid crypto component not found");c=r.AesCryptUtil.decryptAesGcm(e,o.getEncWorkKey(),o.getRootKey())}else c=r.AesCryptUtil.decryptAesGcm(e,t.getEncWorkKey(),t.getRootKey())}catch(t){s.OhpmLazyLogger.error("fail to decrypt data: ",t.message)}finally{t.destroy(),o&&o.destroy()}return c}))}getVersion(){const t=new n.Crypto(this.metaDir);let e=null;try{e=t.getCryptoVersion()}catch(t){s.OhpmLazyLogger.error("fail to get crypto version: ",t.message)}finally{t.destroy()}return e}static generateRSAKeyPair(){return t(this,void 0,void 0,(function*(){const t={modulusLength:2048,publicKeyEncoding:{type:"pkcs1",format:"pem"},privateKeyEncoding:{type:"pkcs1",format:"pem"}};return new Promise(((e,r)=>{(0,c.generateKeyPair)("rsa",t,((t,n,i)=>{if(t)r(t);else{const t=n.toString(),r=i.toString();e({publicKey:t,privateKey:r})}}))}))}))}static rsaDecrypt(e,r){return t(this,void 0,void 0,(function*(){return(0,c.privateDecrypt)(e,Buffer.from(r,"base64")).toString()}))}}exports.CryptoUtil=y;