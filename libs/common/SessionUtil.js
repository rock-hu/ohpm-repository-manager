"use strict";var e=this&&this.__awaiter||function(e,i,t,s){return new(t||(t=Promise))((function(o,r){function n(e){try{d(s.next(e))}catch(e){r(e)}}function c(e){try{d(s.throw(e))}catch(e){r(e)}}function d(e){var i;e.done?o(e.value):(i=e.value,i instanceof t?i:new t((function(e){e(i)}))).then(n,c)}d((s=s.apply(e,i||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SessionUtil=void 0;const i=require("./ErrorCode"),t=require("../packages/log"),s=require("../utils/CommonConstants"),o=require("../service/loginStatus/LoginStatusService"),r=require("./RepoResponse"),n=require("./RepoError"),c=require("../plugins/cache/CacheFactory"),d=require("../service/accessToken/AccessTokenService"),a=require("./AccessTokenType"),u=require("../service/client/login/OhUserInfo"),h=require("../service/user/UserService"),l=require("../packages/config/config"),S=require("../plugins/auth/CustomAuth");class v{constructor(){this.cache={},this.dbCache=c.CacheFactory.createCache({mode:"db"}),this.loginStatusService=o.LoginStatusService.getInstance()}save(i,t,o){return e(this,void 0,void 0,(function*(){if(i&&t){const e=(new Date).getTime();this.cache[v.SESSIONID_KEY+i]={userId:t,lastModifiedTime:e},this.cache[v.USERID_KEY+t]=i,yield this.dbCache.set(s.USER_NEED_CHANGE_PASSWORD_PRE+t,{needChangePassword:o},{isCachedForever:!0}),yield this.loginStatusService.addLoginStatus(t,i,e,o)}}))}get(i){return e(this,void 0,void 0,(function*(){let e=this.cache[v.SESSIONID_KEY+i];return e||(e=yield this.loginStatusService.getInfoBySessionId(i)),e}))}getSessionIdByUserId(i){return e(this,void 0,void 0,(function*(){let e=this.cache[v.USERID_KEY+i];return e||(e=yield this.loginStatusService.getSessionByUserId(i)),e}))}isSessionExist(i){return e(this,void 0,void 0,(function*(){return void 0!==(yield this.get(i))}))}static isExpired(e){return(new Date).getTime()-e>v.EXPIRATION_TIME}isSessionValid(i){return e(this,void 0,void 0,(function*(){if(!(yield this.isSessionExist(i)))return!1;const e=yield this.get(i);return v.isExpired(e.lastModifiedTime)?(delete this.cache[e.userId],delete this.cache[v.SESSIONID_KEY+i],yield this.loginStatusService.delStatusBySessionId(i),!1):(yield this.save(i,e.userId,!1),!0)}))}clearExpiredSessions(){setInterval((()=>e(this,void 0,void 0,(function*(){for(const e in this.cache)if({}.hasOwnProperty.call(this.cache,e)){const i=this.cache[e];if(v.isExpired(i.lastModifiedTime)){const t=i.userId;delete this.cache[v.USERID_KEY+t],delete this.cache[e],yield this.loginStatusService.delStatusByUserId(t)}}}))),v.EXPIRATION_TIME)}deleteSession(i){return e(this,void 0,void 0,(function*(){const e=yield this.get(i);delete this.cache[v.USERID_KEY+e.userId],delete this.cache[v.SESSIONID_KEY+i],yield this.loginStatusService.delStatusBySessionId(i)}))}deleteSessionByUserId(i){return e(this,void 0,void 0,(function*(){const e=yield this.getSessionIdByUserId(i);e&&delete this.cache[v.SESSIONID_KEY+e],delete this.cache[v.USERID_KEY+i],yield this.loginStatusService.delStatusByUserId(i)}))}}v.EXPIRATION_TIME=18e5,v.SESSIONID_KEY="SESSION:SESSIONID:",v.USERID_KEY="SESSION:USERID:";const I=new v;I.clearExpiredSessions();class g{static check(t,o,c){return e(this,void 0,void 0,(function*(){const e=t.cookies.sessionId;if(e&&(yield I.isSessionValid(e))){const o=yield I.get(e),r=yield g.dbCache.get(s.USER_NEED_CHANGE_PASSWORD_PRE+o.userId);r||(r.needChangePassword=o.needChangePassword);const d=t.route.path;if((!r||r.needChangePassword)&&"/:id/password"!==d)throw new n.RepoClientError(i.ErrorCode.UserNeedChangePassword,"user need change password.");g.buildReqCtx(t,o.userId,e),c()}else r.RepoResponse.unauthorized(o)}))}static clientCheck(i,s,o){return e(this,void 0,void 0,(function*(){const e=i.headers.authorization;let n;if(!e)return t.OhpmLazyLogger.error("authorization is undefined."),void r.RepoResponse.unauthorized(s);if(l.config.auth_plugin){const i=yield S.CustomAuth.getInstance().auth(e);n=new u.OhUserInfo(i),n.getId()?t.OhpmLazyLogger.debug("use customized accessToken authentication."):t.OhpmLazyLogger.warn("fail to use the customized accessToken authentication.")}if(!(null==n?void 0:n.getId())&&g.isAccessToken(e)){const i=yield g.accessTokenService.getUserIdByTokenAndType(e,a.AccessTokenType.READ_WRITE);if(!i)return t.OhpmLazyLogger.error("read-write accessToken associated with the provided authorization is invalid."),void r.RepoResponse.unauthorized(s,"read-write accessToken associated with the provided authorization is invalid");const o=yield h.userService.getUserByUserId(i);if(!o)return t.OhpmLazyLogger.error("the user associated with the valid accessToken does not exist."),void r.RepoResponse.unauthorized(s,"the user associated with the valid accessToken does not exist");n=new u.OhUserInfo(o),t.OhpmLazyLogger.debug("use accessToken authentication.")}if(!(null==n?void 0:n.getId())){if(n=yield g.dbCache.get(e),!n)return t.OhpmLazyLogger.error("authorization is expired."),void r.RepoResponse.unauthorized(s,"authorization is expired");t.OhpmLazyLogger.debug("use public and private keys authentication")}i.ctx=i.ctx||{},i.ctx.userJson=n,o()}))}static buildReqCtx(e,i,t){e.ctx=e.ctx||{},e.ctx.userId=i,e.ctx.sessionId=t}static save(i,t,s){return e(this,void 0,void 0,(function*(){yield I.save(i,t,s)}))}static remove(i){return e(this,void 0,void 0,(function*(){yield I.deleteSession(i)}))}static deleteSessionByUserId(e){I.deleteSessionByUserId(e).then()}static checkUser(i,t,s){return e(this,void 0,void 0,(function*(){const e=i.cookies.sessionId;if(e&&(yield I.isSessionValid(e))){const t=yield I.get(e);g.buildReqCtx(i,t.userId,e),s()}else r.RepoResponse.success(t,{userLogin:!1})}))}static isAccessToken(e){if(!e)return!1;if(!g.BASE64_REGEX.test(e))return!1;const i=Buffer.from(e,"base64").toString();return g.UUID_REGEX.test(i)}}exports.SessionUtil=g,g.dbCache=c.CacheFactory.createCache({mode:"db"}),g.BASE64_REGEX=/^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/,g.UUID_REGEX=/^[0-9a-fA-F]{32}$/,g.accessTokenService=d.AccessTokenService.getInstance();