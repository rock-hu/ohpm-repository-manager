"use strict";var e=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))((function(o,s){function a(e){try{d(i.next(e))}catch(e){s(e)}}function n(e){try{d(i.throw(e))}catch(e){s(e)}}function d(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,n)}d((i=i.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.DistTagsService=void 0;const r=require("../../../common/RepoError"),i=require("../../../common"),o=require("../../../utils/CommonConstants"),s=require("../../user/UserService"),a=require("./DistTagsRepository"),n=t(require("semver/functions/valid")),d=require("../../package/PackageRepository"),c=require("../../../entity/DistTags");class g{static getInstance(){return this.Instance||(this.Instance=new g(a.DistTagsRepository.getInstance())),this.Instance}constructor(e){this.distTagsRepository=e}addTag(t,o,a,n,d){return e(this,void 0,void 0,(function*(){yield s.userService.validPermission(o,a,d,t),this.validParameter(n,d),yield this.validVersionExist(o,a,d);const e=yield this.distTagsRepository.findByRepoNameAndPkgNameAndTag(o,a,n);if(e&&e.recordList&&e.recordList.length>0)throw new r.RepoClientError(i.ErrorCode.TagExistError,`The package "${a}" tag "${n}" is existed!`);const g=new c.DistTags(o,a,d,n,t.getId());yield this.distTagsRepository.insert(g)}))}updateTag(t,o,a,n,d){return e(this,void 0,void 0,(function*(){yield s.userService.validPermission(o,a,d,t),this.validParameter(n,d),yield this.validVersionExist(o,a,d);const e=yield this.distTagsRepository.findByRepoNameAndPkgNameAndTag(o,a,n);if(!e||!e.recordList||0===e.recordList.length)throw new r.RepoClientError(i.ErrorCode.TagNotExistError,`The package "${a}" tag "${n}" not exist!`);const c=e.recordList[0];c.version=d,c.lastOprUserId=t.getId(),c.updateTime=(new Date).getTime(),yield this.distTagsRepository.updateById(c.id,c)}))}deleteTag(t,o,a,n){return e(this,void 0,void 0,(function*(){yield s.userService.validPermission(o,a,"",t),this.validParameter(n);const e=yield this.distTagsRepository.findByRepoNameAndPkgNameAndTag(o,a,n);if(!e||!e.recordList||0===e.recordList.length)throw new r.RepoClientError(i.ErrorCode.TagNotExistError,`The package "${a}" tag "${n}" not exist!`);yield this.distTagsRepository.deleteById(e.recordList[0].id)}))}deleteTagByPkg(t,r,i){return e(this,void 0,void 0,(function*(){const e={repoName:t,packageName:r};i&&(e.version={in:i}),yield this.distTagsRepository.deleteByQueryFilter(e)}))}insertTag(t){return e(this,void 0,void 0,(function*(){yield this.distTagsRepository.insert(t)}))}validPkgHasTag(t,o,s){return e(this,void 0,void 0,(function*(){if(s){const e=yield this.distTagsRepository.findByRepoNameAndPkgNameAndVersions(t,o,s);if(e&&e.recordList&&e.recordList.length>0){const t=e.recordList.map((e=>e.tag)).join(",");throw new r.RepoClientError(i.ErrorCode.PkgHasTagError,`The package "${o}@${s}" has tag: ${t}, delete the tag and then remove the package.`)}}else{const e=yield this.distTagsRepository.findByRepoNameAndPkgName(t,o);if(e&&e.recordList&&e.recordList.length>0){const t=e.recordList.map((e=>e.tag)).join(",");throw new r.RepoClientError(i.ErrorCode.PkgHasTagError,`The package "${o}" has tag: ${t}, delete the tag and then remove the package.`)}}}))}getMetadataDistTags(t,r){return e(this,void 0,void 0,(function*(){const e={},i=yield this.distTagsRepository.findByRepoNameAndPkgName(t,r);if(!i||!i.recordList||0===i.recordList.length)return e;return i.recordList.forEach((t=>e[t.tag]=t.version)),e}))}getDistTagsArray(t,r){return e(this,void 0,void 0,(function*(){const e=yield this.distTagsRepository.findByRepoNameAndPkgName(t,r);return e&&e.recordList&&0!==e.recordList.length?e.recordList:[]}))}validVersionExist(t,o,s){return e(this,void 0,void 0,(function*(){const e=yield d.packageRepository.getManifestByName(t,o,s);if(!e||!e.recordList||0===e.recordList.length)throw new r.RepoClientError(i.ErrorCode.PackageNotExist,`The package "${o}@${s}" does not exist!`)}))}validTag(e){if(!this.isTag(e))throw new r.RepoClientError(i.ErrorCode.InvalidTagError,`Invalid tag "${e}": The tag must start with a letter or a number and can only consist of letters, numbers, periods ("."), hyphens ("-") and underscores ("_"), with a maximum length of 60 characters, and cannot be "latest".`);if(e===g.ReservedTag)throw new r.RepoClientError(i.ErrorCode.InvalidTagError,'The reserved "latest" character cannot be used for tag')}validVersion(e){if(!(0,n.default)(e))throw new r.RepoClientError(i.ErrorCode.InvalidVersion,`The version: ${e} does not satisfy the semver specification.`)}validParameter(e,t){this.validTag(e),t&&this.validVersion(t)}validPublishTag(t,o,s){return e(this,void 0,void 0,(function*(){if(t&&t!==g.ReservedTag){if(!this.isTag(t))throw new r.RepoClientError(i.ErrorCode.InvalidTagError,`Invalid tag "${t}": The tag must start with a letter or a number and can only consist of letters, numbers, periods ("."), hyphens ("-") and underscores ("_"), with a maximum length of 60 characters, and cannot be "latest".`);const e=yield this.distTagsRepository.findByRepoNameAndPkgNameAndTag(o,s,t);if(e&&e.recordList&&e.recordList.length>0)throw new r.RepoClientError(i.ErrorCode.TagExistError,`The upload package "${s}" tag "${t}" is existed, delete the existed tag or use another tag before publish the package`)}}))}isTag(e){return o.TAG_REGEX.test(e)}}exports.DistTagsService=g,g.ReservedTag="latest";