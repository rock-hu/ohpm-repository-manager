"use strict";var e=this&&this.__awaiter||function(e,t,o,r){return new(o||(o=Promise))((function(i,n){function s(e){try{l(r.next(e))}catch(e){n(e)}}function a(e){try{l(r.throw(e))}catch(e){n(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof o?t:new o((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SftpStorage=void 0;const o=t(require("path")),r=require("../../utils/FsUtil"),i=require("../../packages/log"),n=require("../../packages/config/config"),s=require("../../common/Constants"),a=require("../../utils/CommonUtil"),l=require("../../utils/CryptoUtil"),c=require("./SftpConnectPool"),f=require("../../service/deployedInstance/DeployedInstanceService"),d=require("../../utils/RandomUtil"),h=t(require("ssh2-sftp-client")),p=require("./SftpOperate"),g=require("../../packages/config/constants"),m=require("../../service/downloadFailure/DownloadFailureService"),u=require("../../common/RepoError"),y=require("../../common"),w=require("../../service/package/PackageRepository"),S=require("../../service/client/publish/PublishService"),C=require("lodash"),v=require("./calculateHashAndKeepContent"),E=["localhost","127.0.0.1","0.0.0.0"];var L;!function(e){e.READ="read",e.WRITE="write"}(L||(L={}));const _=/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,O=/^[0-9A-Za-z.\-_\u4e00-\u9fa5]{3,1024}$/;exports.SftpStorage=class{sftpConnect(t,o){return e(this,void 0,void 0,(function*(){const e=new h.default(t.name),r=o===L.READ?t.read_username:t.write_username,n=o===L.READ?t.read_password:t.write_password,s=l.CryptoUtil.getVersion(),a=yield l.CryptoUtil.decrypt(n,s);return yield e.connect({host:t.host,port:t.port,username:r,password:a}).catch((e=>{throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, name is "${t.name}" config incorrect, "${e.message}".`),new Error('"sftp" is configured wrong')})),e}))}readWriteConnect(t,r){return e(this,void 0,void 0,(function*(){const e=yield this.sftpConnect(t,r);yield e.exists(t.path).then((e=>{if("d"!==e)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, name is "${t.name}" config incorrect, path must be an existing directory.`),new Error('"sftp" is configured wrong')}));try{if(r===L.READ)yield e.list(t.path);else{const r=d.RandomUtil.generateUUID(),i=o.default.posix.join(t.path,`${r}.tmp`);yield e.mkdir(i,!0),yield e.rmdir(i,!0)}}catch(e){throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, name is "${t.name}" config incorrect, "${r}" permission is denied.`),new Error('"sftp" is configured wrong')}finally{yield e.end()}}))}checkSingleMachine(t,o){return e(this,void 0,void 0,(function*(){let e=!1;const n="/DeployedInstance.json",s=yield p.SftpOperate.exists(t.name,n);if(!s&&0!==o.length)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, database has a machine list, but "sftp[${t.name}]" directory does not.`),new Error('"sftp" is configured wrong');if(s||0!==o.length||(e=!0),e)return;yield p.SftpOperate.get(t.name,n,this.machine_file_tmp_path);const a=yield r.FsUtil.readJSON5(this.machine_file_tmp_path);if(0===a.length&&0!==o.length)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, database has a machine list, but "sftp[${t.name}]" directory does not.`),new Error('"sftp" is configured wrong');if(0!==a.length&&0===o.length)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, "sftp[${t.name}]" directory has a machine list, but database does not.`),new Error('"sftp" is configured wrong');if(o.length!==a.length)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, database machine list is different from the "sftp[${t.name}]" list.`),new Error('"sftp" is configured wrong');o.map((e=>{let o=!1;if(a.map((t=>(t.machine===e.machine&&(o=!0),null))),!o)throw i.OhpmLazyLogger.error(`"sftp" is configured wrong, database machine list is different from the "sftp[${t.name}]" list.`),new Error('"sftp" is configured wrong');return null}))}))}checkMachineList(t){return e(this,void 0,void 0,(function*(){for(let e=0;e<this.locationConf.length;e++){const o=this.locationConf[e];yield this.checkSingleMachine(o,t)}}))}writeDeployedInfo(t){return e(this,void 0,void 0,(function*(){for(let e=0;e<this.locationConf.length;e++){yield r.FsUtil.writeFile(this.machine_file_tmp_path,JSON.stringify(t,null,2));const o=this.locationConf[e],i="/DeployedInstance.json";yield p.SftpOperate.put(o.name,this.machine_file_tmp_path,i)}}))}init(){return e(this,void 0,void 0,(function*(){const e=(0,C.cloneDeep)(n.config.store.config.location);if(!e)throw new Error('config "store.config.location" is empty');if(this.server=a.CommonUtil.getServerAddress(),e.length<1||e.length>3)throw new Error('"config store.config.location" must be "[1, 3]" SFTP configurations');for(let t=0;t<e.length;t++)this.checkSftpConf(e[t]),Object.keys(e[t]).map((o=>(e[t][o]=e[t][o].toString(),null)));const t=new Set;if(e.map((e=>(t.add(e.name),null))),t.size!==e.length)throw new Error('config "name" for sftp is empty');this.locationConf=e;for(let e=0;e<this.locationConf.length;e++){const t=this.locationConf[e];yield this.readWriteConnect(t,L.READ),yield this.readWriteConnect(t,L.WRITE)}const i={};for(let e=0;e<this.locationConf.length;e++)i[this.locationConf[e].name]=yield c.SftpPoolFactory.getSftpPool(this.locationConf[e]);p.SftpOperate.setPools(i);const l=yield f.deployedInstanceService.getDeployedInstanceList(),d=o.default.posix.join(s.Constants.DATA_DIR,"temp");yield r.FsUtil.createDirIfNotExists(d),this.machine_file_tmp_path=o.default.posix.join(d,"DeployedInstance.json"),yield this.checkMachineList(l.recordList);const h=a.CommonUtil.getHostName(),m=n.config.listen.port.toString(),u=s.Constants.VERSION,y=yield(0,n.readCryptoVersion)(g.PathConstants.CRYPTO_VERSION_PATH),w=yield(0,n.readCryptoVersion)(g.PathConstants.NEW_CRYPTO_VERSION_PATH);let S=!1;for(let e=0;e<l.total;e++)if(l.recordList[e].machine===h){S=!0;break}if(!S){const e=l.recordList;e.push({machine:h,port:m,version:u,cryptoVersion:y,newCryptoVersion:w}),yield f.deployedInstanceService.addDeployedInstance(h,m,u,y,w),yield this.writeDeployedInfo(e)}yield r.FsUtil.rm(this.machine_file_tmp_path)}))}removeInstance(){return e(this,void 0,void 0,(function*(){const e=n.config.store.config.location;for(let t=0;t<e.length;t++)this.checkSftpConf(e[t]),Object.keys(e[t]).map((o=>(e[t][o]=e[t][o].toString(),null)));this.locationConf=e;for(let e=0;e<this.locationConf.length;e++){const t=this.locationConf[e];yield this.readWriteConnect(t,L.READ),yield this.readWriteConnect(t,L.WRITE)}const t={};for(let e=0;e<this.locationConf.length;e++)t[this.locationConf[e].name]=yield c.SftpPoolFactory.getSftpPool(this.locationConf[e]);p.SftpOperate.setPools(t);const i=yield f.deployedInstanceService.getDeployedInstanceList(),l=o.default.posix.join(s.Constants.DATA_DIR,"temp");yield r.FsUtil.createDirIfNotExists(l),this.machine_file_tmp_path=o.default.posix.join(l,"DeployedInstance.json"),yield this.checkMachineList(i.recordList);const d=a.CommonUtil.getHostName();let h=!1;for(let e=0;e<i.total;e++)if(i.recordList[e].machine===d){h=!0;break}if(!h)throw yield r.FsUtil.rm(this.machine_file_tmp_path),new Error("instance information does not exist in mysql and sftp");{yield f.deployedInstanceService.removeDeployedInstance("machine",d);const e=(yield f.deployedInstanceService.getDeployedInstanceList()).recordList;yield this.writeDeployedInfo(e)}yield r.FsUtil.rm(this.machine_file_tmp_path)}))}delete(t){return e(this,void 0,void 0,(function*(){if(!t)return i.OhpmLazyLogger.warn("sftpStorage: file id is not defined."),!1;if(decodeURIComponent(t).includes(".."))return i.OhpmLazyLogger.warn('sftpStorage: delete id includes ".."!'),!1;yield p.SftpOperate.checkAllPools();for(let e=0;e<this.locationConf.length;e++){const r=this.locationConf[e];try{if(!(yield p.SftpOperate.exists(r.name,t)))return i.OhpmLazyLogger.warn("sftpStorage: file does not exist! id: ",t),!1;yield p.SftpOperate.delete(r.name,t),yield this.deleteRedundantDirs(r.name,o.default.dirname(t),r.path),i.OhpmLazyLogger.info(`sftpStorage [${r.name}]: file delete success! id: `,t)}catch(e){i.OhpmLazyLogger.error(e.message)}}return!0}))}deleteRedundantDirs(t,r,i){return e(this,void 0,void 0,(function*(){if(r===i)return;if((yield p.SftpOperate.stat(t,r)).isDirectory){0===(yield p.SftpOperate.list(t,r)).length&&(yield p.SftpOperate.rmdir(t,r,!0),yield this.deleteRedundantDirs(t,o.default.dirname(r),i))}}))}download(t){return e(this,void 0,void 0,(function*(){const e=n.config.store.config.location,o=t,r=this.fetchInfoById(t),s=[],a=[].concat(JSON.parse(JSON.stringify(e)));a.sort((()=>Math.random()-.5));const l=yield this.sftpDownloadPoll(a,o,r,s);if(s.length===a.length||!l)throw i.OhpmLazyLogger.error("file does not exist, fail to download."),new u.RepoClientError(y.ErrorCode.SftpStorageError,"The download url is invalid");return yield this.saveDownloadFailureLog(t,s),l}))}downloadStream(t){return e(this,void 0,void 0,(function*(){let e;try{const o=n.config.store.config.location,r=t,s=this.fetchInfoById(t),a=[],l=[].concat(JSON.parse(JSON.stringify(o)));if(l.sort((()=>Math.random()-.5)),e=yield this.sftpDownloadPollStream(l,r,s,a),a.length===l.length||!e)throw i.OhpmLazyLogger.error("file does not exist, fail to download."),new u.RepoClientError(y.ErrorCode.SftpStorageError,"The download url is invalid");return yield this.saveDownloadFailureLog(t,a),e}catch(t){throw null==e||e.destroy(),t}}))}saveDownloadFailureLog(t,o){return e(this,void 0,void 0,(function*(){const{repoName:e,packageName:r,version:i}=this.fetchInfoById(t);for(const{sftp:n,error:s}of o){const{name:o,port:a}=n;yield m.downloadFailureService.addDownloadFailure(e,r,i,o,a,t,s)}}))}fetchInfoById(e){const t=e.split("/"),o=t[0];let r,i;return t[1].startsWith("@")?(r=`${t[1]}/${t[2]}`,i=t[3].endsWith(s.Constants.HSP_SUFFIX)?t[3].substring(t[2].length+1,t[3].length-s.Constants.HSP_SUFFIX.length):t[3].endsWith(s.Constants.HAR_SUFFIX)?t[3].substring(t[2].length+1,t[3].length-s.Constants.HAR_SUFFIX.length):t[3].substring(t[2].length+1)):(r=t[1],i=t[2].endsWith(s.Constants.HSP_SUFFIX)?t[2].substring(t[1].length+1,t[2].length-s.Constants.HSP_SUFFIX.length):t[2].endsWith(s.Constants.HAR_SUFFIX)?t[2].substring(t[1].length+1,t[2].length-s.Constants.HAR_SUFFIX.length):t[2].substring(t[1].length+1)),i=e.endsWith(s.Constants.METADATA_FILE_NAME)?"":i,{repoName:o,packageName:r,version:i}}sftpDownloadPoll(t,r,n,s){return e(this,void 0,void 0,(function*(){for(let e=0;e<t.length;e++){const a=t[e],l=a.name;try{yield this.checkFileExist(l,r);const e=yield p.SftpOperate.getFileBuffer(l,r);return o.default.basename(r).endsWith(".har")&&(yield this.checkHarIntegrity(l,o.default.basename(r),n,e)),i.OhpmLazyLogger.debug(`'${o.default.basename(r)}' downloaded successfully.`),e}catch(e){if(e.message.includes("manifest is not found"))throw new u.RepoClientError(y.ErrorCode.SftpStorageError,e.message);i.OhpmLazyLogger.error("fail to download:",e.message),s.push({sftp:a,error:e.message})}}}))}sftpDownloadPollStream(t,r,n,a){return e(this,void 0,void 0,(function*(){for(let e=0;e<t.length;e++){const l=t[e],c=l.name;let f;try{return yield this.checkFileExist(c,r),f=yield p.SftpOperate.getFileStream(c,r),o.default.basename(r).endsWith(s.Constants.HAR_SUFFIX)&&(f=yield this.checkHarIntegrityByStream(c,o.default.basename(r),n,f)),i.OhpmLazyLogger.debug(`'${o.default.basename(r)}' downloaded successfully.`),f}catch(e){if(null==f||f.destroy(),e.message.includes("manifest is not found"))throw new u.RepoClientError(y.ErrorCode.SftpStorageError,e.message);i.OhpmLazyLogger.error("fail to download:",e.message),a.push({sftp:l,error:e.message})}}}))}checkFileExist(t,r){return e(this,void 0,void 0,(function*(){if(!(yield p.SftpOperate.exists(t,r)))throw new u.RepoClientError(y.ErrorCode.SftpStorageError,`In sftp '${t}', the '${o.default.basename(r)}' package does not exists.`)}))}checkHarIntegrity(t,o,r,i){return e(this,void 0,void 0,(function*(){const e={name:r.packageName,version:r.version},n=yield w.packageRepository.findByFilter(e);if(!n.recordList.length)throw new u.RepoClientError(y.ErrorCode.SftpStorageError,`The '${o}' manifest is not found.`);if(n.recordList[0].checksum!==S.publishService.calculatedChecksumByBuffer(i))throw new u.RepoClientError(y.ErrorCode.SftpStorageError,`sftp named '${t}', fail to verify the checksum of the '${o}'.`)}))}checkHarIntegrityByStream(t,o,r,i){return e(this,void 0,void 0,(function*(){let e;try{const n=yield this.getChecksum(o,r),s=yield(0,v.calculateHashAndKeepContent)(i,"sha512");if(e=s.contentStream,n!==s.hash)throw new u.RepoClientError(y.ErrorCode.SftpStorageError,`sftp named '${t}', fail to verify the checksum of the '${o}'.`);return e}catch(t){throw null==e||e.destroy(),t}finally{i.destroy()}}))}getChecksum(t,o){return e(this,void 0,void 0,(function*(){const e={name:o.packageName,version:o.version},r=yield w.packageRepository.findByFilter(e);if(!r.recordList.length)throw new u.RepoClientError(y.ErrorCode.SftpStorageError,`The '${t}' manifest is not found.`);return r.recordList[0].checksum}))}save(t,n){return e(this,void 0,void 0,(function*(){if(!t)throw i.OhpmLazyLogger.warn("sftpStorage: srcPath does not exist."),Error("srcPath does not exist! ");if(!(yield r.FsUtil.exists(t)))throw i.OhpmLazyLogger.info("sftpStorage: srcPath does not exist. packageName: ",n.packageName),Error("srcFile does not exist");const e=o.default.basename(t);let s;if(n.isPackage)s=o.default.posix.join(n.repoName,n.packageName);else{let e;e=n.packageName.startsWith("@")?n.packageName.split("/")[1]:n.packageName,s=o.default.posix.join(n.repoName,n.packageName,`${e}-${n.version}`)}yield p.SftpOperate.checkAllPools();for(let r=0;r<this.locationConf.length;r++){const n=this.locationConf[r];try{(yield p.SftpOperate.exists(n.name,s))||(yield p.SftpOperate.mkdir(n.name,s,!0));const r=o.default.posix.join(s,e);yield p.SftpOperate.put(n.name,t,r)}catch(e){i.OhpmLazyLogger.error(e.message)}}const a=o.default.posix.join(s,e);return i.OhpmLazyLogger.info("save file success. fileId :",a),a}))}checkSftpConf(e){if(!e.name)throw new Error('config "type" for sftp is empty');if(!e.host)throw new Error('config "host" for sftp is empty');if(!e.port)throw new Error('config "port" for sftp is empty');if("number"!=typeof e.port)throw new Error("the type of the sftp port must be a number");if(!e.read_username)throw new Error('config "read_username" for sftp is empty');if(!e.read_password)throw new Error('config "read_password" for sftp is empty');if(!e.write_username)throw new Error('config "write_username" for sftp is empty');if(!e.write_password)throw new Error('config "write_password" for sftp is empty');if(e.path||(e.path="/"),e.path&&e.path.includes(".."))throw new Error('"path" of "sftp" is configured wrong: the relative path cannot contain ../ ');if(e.port<1||e.port>65535)throw i.OhpmLazyLogger.error('parse "sftp port" error, please refer the examples in the config.yaml file.'),new Error('parse "listen address" from config.yaml error');if(!E.some((t=>e.host===t)))if(/^[0-9.]*$/.exec(e.host)){if(!_.test(e.host))throw i.OhpmLazyLogger.error('parse "sftp host" error, please refer the examples in the config.yaml file.'),new Error('parse "sftp host" from config.yaml error')}else if(!O.exec(e.host)||e.host.indexOf(".")<0)throw i.OhpmLazyLogger.error('parse "sftp host" error, please refer the examples in the config.yaml file.'),new Error('parse "sftp host" from config.yaml error')}};