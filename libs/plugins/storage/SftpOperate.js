"use strict";var t=this&&this.__awaiter||function(t,e,o,i){return new(o||(o=Promise))((function(n,s){function r(t){try{c(i.next(t))}catch(t){s(t)}}function a(t){try{c(i.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?n(t.value):(e=t.value,e instanceof o?e:new o((function(t){t(e)}))).then(r,a)}c((i=i.apply(t,e||[])).next())}))},e=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SftpOperate=void 0;const o=require("../../packages/log"),i=e(require("path")),n=require("../../packages/config/config"),s=require("../../common/Constants");var r;!function(t){t.READ="read",t.WRITE="write"}(r||(r={}));exports.SftpOperate=class{static getConn(e,o){return t(this,void 0,void 0,(function*(){const t=this.pools[e];if(!t.isAvailable())throw new Error(`the sftp service named "${e}" is interrupted`);return t.assign(o)}))}static checkAllPools(){return t(this,void 0,void 0,(function*(){const t=Object.keys(this.pools).length;let e=0;for(const t in this.pools)this.pools[t].isAvailable()&&e++;if(t>1&&e<2||e<1)throw new Error("sftp service error. Please check")}))}static closeConn(e,o,i){return t(this,void 0,void 0,(function*(){const t=this.pools[e];yield t.release(o.getId(),i)}))}static getSftpRootPath(t){let e;this.configSftps||(this.configSftps=n.config.store.config.location);for(const o of this.configSftps)if(o.name===t)return e=o.path?o.path:"/",e;throw new Error(`the ${t} sftp configuration does not exist`)}static getRootRemotePath(t,e){return i.default.posix.join(this.getSftpRootPath(t),e)}static get(e,i,n){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),s=yield this.getConn(e,r.READ);try{yield s.getSftpConn().fastGet(t,n)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to get file:`,t.message),t}finally{yield this.closeConn(e,s,r.READ)}}))}static getFileBuffer(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.READ);try{let o=Buffer.allocUnsafe(0);const i=yield n.getSftpConn().createReadStream(t);return i.on("data",(t=>{o=Buffer.concat([o,t])})),new Promise(((t,e)=>{i.once("end",(()=>t(o))),i.once("error",(t=>e(t)))}))}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to get file:`,t.message),t}finally{yield this.closeConn(e,n,r.READ)}}))}static getFileStream(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.READ);try{return n.getSftpConn().createReadStream(t)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to get file:`,t.message),t}finally{yield this.closeConn(e,n,r.READ)}}))}static put(e,i,n,a=s.Constants.PERMISSIONS750){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,n),s=yield this.getConn(e,r.WRITE);try{yield s.getSftpConn().fastPut(i,t),yield this.setPathPermission(e,n,a)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to put file:`,t.message),t}finally{yield this.closeConn(e,s,r.WRITE)}}))}static exists(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.READ);try{return!!(yield n.getSftpConn().exists(t))}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to find file:`,t.message),t}finally{yield this.closeConn(e,n,r.READ)}}))}static delete(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.WRITE);try{yield n.getSftpConn().delete(t)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to delete file:`,t.message),t}finally{yield this.closeConn(e,n,r.WRITE)}}))}static stat(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.READ);try{return n.getSftpConn().stat(t)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to get file stat:`,t.message),t}finally{yield this.closeConn(e,n,r.READ)}}))}static list(e,i){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),n=yield this.getConn(e,r.READ);try{return n.getSftpConn().list(t)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to get directory list:`,t.message),t}finally{yield this.closeConn(e,n,r.READ)}}))}static rmdir(e,i,n=!1){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),s=yield this.getConn(e,r.WRITE);try{return s.getSftpConn().rmdir(t,n)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to remove directory:`,t.message),t}finally{yield this.closeConn(e,s,r.WRITE)}}))}static mkdir(e,i,n=!1){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),s=yield this.getConn(e,r.WRITE);try{return s.getSftpConn().mkdir(t,n)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to create directory:`,t.message),t}finally{yield this.closeConn(e,s,r.WRITE)}}))}static chmod(e,i,n){return t(this,void 0,void 0,(function*(){const t=this.getRootRemotePath(e,i),s=yield this.getConn(e,r.WRITE);try{return s.getSftpConn().chmod(t,n)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to chmod:`,t.message),t}finally{yield this.closeConn(e,s,r.WRITE)}}))}static setPathPermission(e,n,s){return t(this,void 0,void 0,(function*(){const t=this.getSftpRootPath(e),r=i.default.posix.join(t,n);try{yield this.setPermission(e,r,t,s)}catch(t){throw o.OhpmLazyLogger.error(`sftp named "${e}" fail to set permission:`,t.message),t}}))}static setPermission(e,o,n,s){return t(this,void 0,void 0,(function*(){if(o===n)return;const t=yield this.getConn(e,r.WRITE);try{yield t.getSftpConn().chmod(o,s)}finally{yield this.closeConn(e,t,r.WRITE)}yield this.setPermission(e,i.default.dirname(o),n,s)}))}static setPools(t){this.pools=t}static getPools(){return this.pools}};