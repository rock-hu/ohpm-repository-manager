"use strict";var e=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(o,i){function s(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}c((n=n.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.keyManageService=void 0;const r=require("../../packages/crypto"),n=require("../../packages/log"),o=require("../../common/RepoError"),i=require("../../common"),s=t(require("path")),a=require("../../common/Constants"),c=require("../../utils/FsUtil"),y=require("../../packages/crypto/base"),l=require("./ReEncryptEventManager"),u=require("../../packages/config/config"),d=require("../../common/DbAndStoreType");exports.keyManageService=new class{constructor(){this.reEncryptEventManager=l.ReEncryptEventManager.getInstance()}resetKey(){return e(this,void 0,void 0,(function*(){n.OhpmLazyLogger.info("begin to resetKey...");const e=Date.now();let t;try{t=yield this.generateNewCrypto(),yield this.reEncryptEventManager.reEncrypt(t),yield this.removeOldMeta(),yield this.renameNewMeta(),n.OhpmLazyLogger.info(`resetKey success, cost: ${Date.now()-e}ms.`)}finally{t&&t.destroy()}}))}subscribeReEncryptEvent(e){this.reEncryptEventManager.subscribe(e)}encrypt(e,t){if(!t)throw new o.RepoClientError(i.ErrorCode.InvalidEncryptionComponent,"Encrypt, crypto is null!");return y.AesCryptUtil.encryptAesGcm(e,t.getEncWorkKey(),t.getRootKey())}generateNewCrypto(){return e(this,void 0,void 0,(function*(){const e=s.default.join(a.Constants.DATA_DIR,a.Constants.NEW_KEY_DIR_NAME);if(!this.isLocalMode()||(yield c.FsUtil.exists(e))&&0!==(yield c.FsUtil.readdir(e)).length||(yield(0,r.createKey)(e)),(yield c.FsUtil.exists(e))&&!(yield(0,r.validKey)(e)))throw new o.RepoClientError(i.ErrorCode.InvalidEncryptionComponent,"Invalid meteNew directory");return new r.Crypto(e)}))}isLocalMode(){const e=!(u.config.db.type!==d.DbType.FileDb||u.config.store.type!==d.StorageType.Fs);if(!e)throw new o.RepoClientError(i.ErrorCode.NoSupportMultiInstance,"The multi-instance mode does not support key resetting.");return e}removeOldMeta(){return e(this,void 0,void 0,(function*(){const e=s.default.join(a.Constants.DATA_DIR,a.Constants.KEY_DIR_NAME);n.OhpmLazyLogger.debug(`begin to remove old meta directory: ${e}`),(yield c.FsUtil.exists(e))&&(yield c.FsUtil.rm(e,{recursive:!0,force:!0}),n.OhpmLazyLogger.info("remove old meta directory succeed."))}))}renameNewMeta(){return e(this,void 0,void 0,(function*(){const e=s.default.join(a.Constants.DATA_DIR,a.Constants.NEW_KEY_DIR_NAME);(yield c.FsUtil.exists(e))&&(yield c.FsUtil.rename(e,s.default.join(a.Constants.DATA_DIR,a.Constants.KEY_DIR_NAME)),n.OhpmLazyLogger.info("rename metaNew -> meta success."))}))}};