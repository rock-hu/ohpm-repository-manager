"use strict";var e=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))((function(n,o){function c(e){try{a(i.next(e))}catch(e){o(e)}}function s(e){try{a(i.throw(e))}catch(e){o(e)}}function a(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(c,s)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SecurityService=void 0;const t=require("../../plugins/cache/CacheFactory"),r=require("../../utils/CryptoUtil"),i=require("../../utils/RandomUtil"),n=require("../../common/RepoError"),o=require("../../common");class c{static getInstance(){if(!this.Instance){const e=t.CacheFactory.createCache({mode:"db"});this.Instance=new c(e)}return this.Instance}constructor(e){this.cache=e}generatePublicKey(){return e(this,void 0,void 0,(function*(){const e=i.RandomUtil.generateUUID(),{publicKey:t,privateKey:n}=yield r.CryptoUtil.generateRSAKeyPair();return yield this.cache.set(`${c.PRIVATE_KEY_CACHE_PREFIX}${e}`,n,{ttl:60}),{keyPairId:e,publicKey:t}}))}decrypt(t,i){return e(this,void 0,void 0,(function*(){const e=yield this.cache.get(`${c.PRIVATE_KEY_CACHE_PREFIX}${t}`);if(!e)throw new n.RepoClientError(o.ErrorCode.KeyPairIdNotExist,`keyPairId "${t}" is not exist`);return r.CryptoUtil.rsaDecrypt(e,i)}))}generateNonce(){return e(this,void 0,void 0,(function*(){const e=i.RandomUtil.generateRandomSecretKey();return yield this.cache.set(`${c.NONCE_PREFIX}${e}`,{used:!1},{ttl:60}),e}))}markNonceAsUsed(t){return e(this,void 0,void 0,(function*(){if(!t)throw new n.RepoClientError(o.ErrorCode.InvalidRequest,"missing anti-replay token in request");const e=yield this.cache.get(`${c.NONCE_PREFIX}${t}`);if(!e)throw new n.RepoClientError(o.ErrorCode.InvalidRequest,"missing anti-replay token in cache");if(e.used)throw new n.RepoClientError(o.ErrorCode.InvalidRequest,"anti-replay token is used");yield this.cache.set(`${c.NONCE_PREFIX}${t}`,{used:!0},{ttl:60})}))}}exports.SecurityService=c,c.PRIVATE_KEY_CACHE_PREFIX="PRIVATE:TMP_KEY:",c.NONCE_PREFIX="PRIVATE:NONCE:";