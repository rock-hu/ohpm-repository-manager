"use strict";var e=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))((function(o,n){function a(e){try{l(i.next(e))}catch(e){n(e)}}function s(e){try{l(i.throw(e))}catch(e){n(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,s)}l((i=i.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.OHPackageChecker=void 0;const r=require("../utils/CommonConstants"),i=require("./RepoError"),o=require("./index"),n=require("../packages/log"),a=t(require("path")),s=t(require("semver/functions/valid")),l=require("./Constants"),c=require("./InjectValidator"),d=require("../utils/CommonUtil"),u=["name","version","description","license","author","main","keywords","repository","homepage","artifactType","types","dependencies","devDependencies"];exports.OHPackageChecker=class{static ensureValidPkgName(e){if(!e)throw new i.RepoClientError(o.ErrorCode.InvalidPackageName,"OHPM package name is empty.");if(e.startsWith("@")&&!r.OHPM_PACKAGE_NAME_GROUP_MATCH_REGEX.test(e))throw new i.RepoClientError(o.ErrorCode.PublishInvalidGroupName,`Package name: ${e}, where the group does not comply with the OHPM package specifications.`);for(const t of r.OHPM_NOT_ALLOWED_PACKAGE_NAME_SUFFIX_ARR)if(e.endsWith(t))throw new i.RepoClientError(o.ErrorCode.InvalidPackageName,`Invalid OHPM package name: ${e}.`);if(!r.OHPM_PACKAGE_NAME_REGEX.test(e))throw new i.RepoClientError(o.ErrorCode.InvalidPackageName,`Invalid OHPM package name: ${e}.`)}static ensureValidSemVer(e){if(!e||!(0,s.default)(e))throw new i.RepoClientError(o.ErrorCode.InvalidVersion,`Version ${e} is invalid!`)}static ensureValidPackageFile(t,n,s){return e(this,void 0,void 0,(function*(){this.ensureRequiredKeys(n);const e=n.artifactType;if(e&&"string"!=typeof e)throw new i.RepoClientError(o.ErrorCode.InvalidArtifactType,"Invalid artifactType value!");const l=n.types;let c=n.main;c||(c=n.types);const u=yield d.CommonUtil.getFilePathFromPkg(s,[l,c]);if(e&&r.NEED_VERIFY_ARTIFACT_TYPE_REGEX.test(e)){if(!l||"string"!=typeof l||0===l.trim().length||!l.endsWith(".d.ts")&&!l.endsWith(".d.ets"))throw new i.RepoClientError(o.ErrorCode.InvalidTypes,"Types value must be a .d.ts or .d.ets file.");let e;try{e=a.default.join(t,l)}catch(e){throw new i.RepoClientError(o.ErrorCode.InvalidTypesPath,`Invalid types value: ${l}!`,e)}if(!u[l])throw new i.RepoClientError(o.ErrorCode.TypesFileNotExist,`Types file "${e}" does not exist`)}if(!c||"string"!=typeof c||0===c.trim().length)throw new i.RepoClientError(o.ErrorCode.InvalidMainValue,"Invalid main or types value!");let p;try{p=a.default.join(t,c)}catch(e){throw new i.RepoClientError(o.ErrorCode.InvalidMainValue,"Invalid main or types value!",e)}if(!u[c])throw new i.RepoClientError(o.ErrorCode.MainFileNotExist,`Main or types file "${p}" does not exist`)}))}static ensureRequiredKeys(e){const t=e.main?r.OHPM_PACKAGE_JSON5_NECESSARY_KEYS_ARR:r.OHPM_PACKAGE_JSON5_HSP_NECESSARY_KEYS_ARR;for(const r of t)if(void 0===e[r])throw new i.RepoClientError(o.ErrorCode.MissRequiredFiled,`oh-package.json5 is missing required field: ${r}`)}static ensureNoInjection(e){let t=Object.entries(e);t=t.filter((e=>u.includes(e[0])));const r=Object.fromEntries(t);this.checkXssAndSqlInjectionRecursively(r,"package")}static checkXssAndSqlInjectionRecursively(e,t,r=1){if(r>5)throw new i.RepoClientError(o.ErrorCode.ComplexStructure,`The structure of the parameter ${t} is too complex.`);const a=typeof e;if("string"===a){if(c.InjectValidator.isInvalid(l.Constants.XSS_INJECT,e)||c.InjectValidator.isInvalid(l.Constants.SQL_INJECT,e))throw new i.RepoClientError(o.ErrorCode.HarmfulContent,`Parameter ${t} may have harmful or malicious content. Be careful to assess the risk and adjust it.`)}else if("object"===a)if(Array.isArray(e))for(const[i,o]of e.entries())this.checkXssAndSqlInjectionRecursively(o,`${t}[${i}]`,r+1);else{const n=Object.keys(e);for(const[a,s]of n.entries()){if(c.InjectValidator.isInvalid(l.Constants.XSS_INJECT,s)||c.InjectValidator.isInvalid(l.Constants.SQL_INJECT,s))throw new i.RepoClientError(o.ErrorCode.HarmfulContent,`Parameter ${t}.keys[${a}] may have harmful or malicious content.\n               Be careful to assess the risk and adjust it.`);this.checkXssAndSqlInjectionRecursively(e[s],`${t}.${s}`,r+1)}}else n.OhpmLazyLogger.info(`${t} type is ${a}, validate pass.`)}static dealAuthorField(e){const t=e.author;if(!t)return void(e.author={name:"",url:"",email:""});if("string"!=typeof t)return;const r=t.match(/^([^(<]+)/),i=t.match(/\(([^)]+)\)/),o=t.match(/<([^>]+)>/),n={name:"",url:"",email:""};r&&r[0].trim()&&(n.name=r[0].trim()),o&&(n.email=o[1]),i&&(n.url=i[1]),e.author=n}static dealArtifactType(e){e.artifactType=e.artifactType?e.artifactType:"original"}};