"use strict";var e=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))((function(n,o){function a(e){try{l(i.next(e))}catch(e){o(e)}}function c(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,c)}l((i=i.apply(e,t||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CommonValidator=void 0;const t=require("./RepoError"),r=require("./ErrorCode"),i=require("../utils/CommonConstants"),n=require("../plugins/cache/CacheFactory"),o=require("./Constants"),a=require("./InjectValidator"),c=/^[a-zA-Z0-9]{1,32}$/,l=/^[a-f0-9]{1,64}$/,s=/^[@/A-Za-z0-9\-_.]{1,128}$/;class h{static checkUUID(e){this.checkStringWithRegex(c,"id",e)}static checkPackageID(e){this.checkStringWithRegex(l,"id",e)}static checkStringWithRegex(e,i,n){if(!e.test(n)){const o=`Invalid parameter: ${i} should match the regular expression ${e}, value = ${n}.`;throw new t.RepoClientError(r.ErrorCode.IllegalParameter,o)}}static checkLength(e,r,i,n,o){if(o){if(!i||i.length>n||i.length<o)throw new t.RepoClientError(e,`Illegal parameter - the ${r} field must contain ${o} - ${n} characters.`)}else if(i&&i.length>n)throw new t.RepoClientError(e,`Illegal parameter - the ${r} field cannot contain more than ${n}.`)}static checkAllSpace(e,r,i){if(i&&""===i.trim())throw new t.RepoClientError(e,`Illegal parameter - the ${r} field cannot contain only Spaces.`)}static checkNotNullStringType(e,t){if(!e||"string"!=typeof e){let r;throw r=t?`The value of ${t} is either empty or not of type string.`:`${e} is not of type string.`,new Error(r)}}static checkNotNullNumberType(e,t){if(!e||"number"!=typeof e){let r;throw r=t?`The value of ${t} is either empty or not of type number.`:`${e} is not of type number.`,new Error(r)}}static verifyVersion(e){if(!e||e.length>h.MAX_API_VERSION_LENGTH)throw new t.RepoClientError(r.ErrorCode.IllegalParameter,"The version is invalid")}static verifyTimestamp(e){if(!e||Math.abs(Date.now()-e)>h.TEN_MIN)throw new t.RepoClientError(r.ErrorCode.IllegalParameter,"The timestamp is expired")}static checkPage(e,i){if(!Number(e)||!Number(i))throw new t.RepoClientError(r.ErrorCode.InvalidPageParam,"Invalid pagination information");if(!e||e<1||!i||i<1)throw new t.RepoClientError(r.ErrorCode.InvalidPageParam,"Invalid pagination information")}static checkName(e){this.checkStringWithRegex(s,"name",e)}static checkDependencyType(e){if(!["dependencies","devDependencies","dynamicDependencies"].includes(e))throw new t.RepoClientError(r.ErrorCode.IllegalParameter,"Invalid type information")}static checkSQLAndXSSInject(e,i){if(i){if(a.InjectValidator.isInvalid(o.Constants.SQL_INJECT,i))throw new t.RepoClientError(r.ErrorCode.SQLInjectRisk,`Illegal parameter - the ${e} filed may have SQL injection risk.`);if(a.InjectValidator.isInvalid(o.Constants.XSS_INJECT,i))throw new t.RepoClientError(r.ErrorCode.XSSInjectRisk,`Illegal parameter - the ${e} filed may have XSS injection risk.`)}}static checkApiCount(n,o,a){return e(this,void 0,void 0,(function*(){const e=`${i.API_ACCESS_CACHE_PRE+o}:${n}`;let c=yield h.cache.get(e),l=1;if(c){const e=(new Date).getTime()-i.ONE_HOUR_MILL_SEC;c=c.filter((t=>t>e)),l=c.length}else c=[];if(l>=a)throw new t.RepoClientError(r.ErrorCode.ApiAccessLimitError,`A maximum of ${a} web api can be access within 1 hours.`);c.push((new Date).getTime()),yield h.cache.set(e,c,{ttl:i.ONE_HOUR_SEC})}))}}exports.CommonValidator=h,h.MAX_API_VERSION_LENGTH=36,h.TEN_MIN=6e5,h.cache=n.CacheFactory.createCache({mode:"db"});