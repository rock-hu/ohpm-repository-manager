"use strict";var e=this&&this.__awaiter||function(e,o,t,i){return new(t||(t=Promise))((function(n,r){function s(e){try{l(i.next(e))}catch(e){r(e)}}function a(e){try{l(i.throw(e))}catch(e){r(e)}}function l(e){var o;e.done?n(e.value):(o=e.value,o instanceof t?o:new t((function(e){e(o)}))).then(s,a)}l((i=i.apply(e,o||[])).next())}))},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.tableName=exports.jsonName=void 0;const t=require("../../packages/log"),i=o(require("log4js")),n=o(require("path")),r=require("../../utils/FsUtil"),s=o(require("compressing")),a=require("../../utils/CommonUtil"),l=require("./type"),d=require("../../common/DbFactory"),p=require("./exportPkgInfoCmd"),c=require("../../packages/crypto"),u=require("../../packages/crypto/base"),y=require("../../utils/CryptoUtil"),m=require("./common/checkInstallAndSetRoot"),f=require("../../service/group/GroupMemberRepository"),g=require("../../entity/GroupMember"),h=require("../../service/publicKeyAuth/PublicKeyRepository"),x=require("../../packages/definitions/types"),b=require("../../service/accessToken/utils/desensitizeToken"),v=require("../../service/user/UserRepository");exports.jsonName={userJson:"user.json",groupMemberJson:"group_member.json",accessTokenJson:"access_token.json",publicKeyJson:"public_key.json",repoJson:"repo.json",uplinkJson:"uplink.json",uplinkProxyJson:"uplink_proxy.json",validationConfigJson:"validation_config.json",meta:"meta",groupJson:"group.json"},exports.tableName={user:"user",groupMember:"group_member",accessToken:"access_token",publicKey:"public_key",repo:"repo",uplink:"uplink",uplinkProxy:"uplink_proxy",validationConfig:"validation_config"};const k=Object.assign(Object.assign({},exports.tableName),{adminAuditLog:"adminAuditLog",cacheData:"cacheData",dependency:"dependency",downloadFailure:"downloadFailure",loginFailure:"loginFailure",loginStatus:"loginStatus",packageManifest:"package_manifest",packageMetadata:"package_metadata"}),j=[exports.jsonName.userJson,exports.jsonName.groupMemberJson,exports.jsonName.accessTokenJson,exports.jsonName.publicKeyJson,exports.jsonName.repoJson,exports.jsonName.uplinkJson,exports.jsonName.uplinkProxyJson,exports.jsonName.validationConfigJson,exports.jsonName.meta],N=new Map;function F(o){return e(this,void 0,void 0,(function*(){for(const[e,t]of N){const i=new RegExp(e,"g");o=o.replace(i,t)}return JSON.parse(o)}))}function J(o,i){return e(this,void 0,void 0,(function*(){const e=new c.Crypto(i);let n="";try{n=u.AesCryptUtil.decryptAesGcm(o,e.getEncWorkKey(),e.getRootKey())}catch(e){t.OhpmLazyLogger.error("fail to decrypt data: ",e.message),process.exit(1)}finally{e.destroy()}return n}))}exports.default=function(o,c){return e(this,void 0,void 0,(function*(){try{yield function(o,i){return e(this,void 0,void 0,(function*(){const c=n.default.resolve(process.cwd(),o);yield(0,m.checkInstallAndSetRoot)();const{tempDir:u,dataDir:_}=yield function(o){return e(this,void 0,void 0,(function*(){if(!(yield r.FsUtil.exists(o)))throw new Error(`"${o}" file does not exist.`);if(!o.endsWith(l.ZIP_TYPE))throw new Error(`"${o}" file is not a zip file.`);const t=a.CommonUtil.genRandomTempDir();yield s.default.zip.uncompress(o,t);let i=yield r.FsUtil.readdir(t),d=t;if(1===i.length){const e=n.default.posix.join(d,i[0]);d=(yield r.FsUtil.stat(e)).isDirectory()?e:t,i=yield r.FsUtil.readdir(d)}if(i.includes(exports.jsonName.groupJson)&&i.includes(exports.jsonName.groupMemberJson)){const o=n.default.posix.join(d,exports.jsonName.groupJson),t=n.default.posix.join(d,exports.jsonName.groupMemberJson);yield function(o,t){return e(this,void 0,void 0,(function*(){const e=JSON.parse(yield r.FsUtil.readFile(o,"utf-8")),i=JSON.parse(yield r.FsUtil.readFile(t,"utf-8")),n=[];for(const o of e){const e=o.id,t=o.owner_name,r=o.create_time,s=o.description,a=o.name,l=i.filter((o=>o.group_id===e));for(const e of l){const o=new g.GroupMember(e);o.setGroupCreateTime(r),o.setGroupDescription(s),o.setGroupName(a),o.getMemberName()===t&&o.getRole()===x.RoleType.Member&&o.setRole(x.RoleType.Admin),o.getMemberName()!==t&&o.getRole()===x.RoleType.Admin&&o.setRole(x.RoleType.Member),n.push(o)}}yield r.FsUtil.writeFile(t,JSON.stringify(n,null,2)),yield r.FsUtil.rm(o)}))}(o,t),i=i.filter((e=>e!==exports.jsonName.groupJson))}const p=n.default.posix.join(d,exports.jsonName.accessTokenJson);yield function(o){return e(this,void 0,void 0,(function*(){if(!(yield r.FsUtil.exists(o)))return;const e=yield r.FsUtil.readJSON(o);for(const o of e)o.sanitizedToken||(o.sanitizedToken=(0,b.desensitizeToken)(o.token),o.token=a.CommonUtil.sha256(o.token));yield r.FsUtil.writeFile(o,JSON.stringify(e,null,2))}))}(p);if(j.sort().join()!==i.sort().join())throw new Error("the data file in the .zip package is incorrect. Do not change the file name, add or delete files.");return{tempDir:t,dataDir:d}}))}(c);try{const o=yield(0,p.loadConfig)("import userInfo");yield(0,d.initDB)(o.db),i.cleanDb&&(yield function(){return e(this,void 0,void 0,(function*(){for(const e of Object.values(k))try{yield d.commonDB.clearTable(e)}catch(o){t.OhpmLazyLogger.error(`fail to clear "${e}" database data, message: ${o.message}`),process.exit(1)}t.OhpmLazyLogger.info("all database data has been cleaned.")}))}()),yield function(o,i){return e(this,void 0,void 0,(function*(){const e=JSON.parse(yield r.FsUtil.readFile(o,"utf-8")),s=[];for(let o=0;o<e.length;o++){const{recordList:t}=yield d.commonDB.findByFilter(exports.tableName.user,{filter:{name:e[o].name}});t.length?e[o].id!==t[0].id&&(s.push(e[o].name),N.set(e[o].id,t[0].id),N.set(e[o].publishId,t[0].publishId)):yield d.commonDB.insertOne(exports.tableName.user,e[o])}s.length&&t.OhpmLazyLogger.warn(`these users ${JSON.stringify(s)} already existing will be not imported from '${n.default.basename(i)}'.`)}))}(n.default.posix.join(_,exports.jsonName.userJson),c),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),t=yield F(e);for(let e=0;e<t.length;e++){0===(yield f.groupMemberRepository.findByFilter({member_name:t[e].member_name,group_name:t[e].group_name})).total&&(yield f.groupMemberRepository.insert(new g.GroupMember(t[e])))}}))}(n.default.posix.join(_,exports.jsonName.groupMemberJson)),yield function(o,i){return e(this,void 0,void 0,(function*(){const e=n.default.posix.join(n.default.dirname(o),exports.jsonName.meta),s=yield r.FsUtil.readFile(o,"utf-8"),a=yield F(s);for(let o=0;o<a.length;o++){if(0===(yield h.publicKeyRepository.findPublicKeyByNameAndUserId(a[o].name,a[o].userId)).total){const t=yield J(a[o].publicKey,e);a[o].publicKey=y.CryptoUtil.encrypt(t),a[o].cryptoVersion=y.CryptoUtil.getVersion(),yield h.publicKeyRepository.insert(a[o])}else{const e=yield v.userRepository.findUserById(a[o].userId);t.OhpmLazyLogger.warn(`the public Key "${a[o].name}" already exists for user "${e.name}", it will not be imported from '${n.default.basename(i)}'.`)}}}))}(n.default.posix.join(_,exports.jsonName.publicKeyJson),c),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),t=yield F(e);for(let e=0;e<t.length;e++){const{recordList:o}=yield d.commonDB.findByFilter(exports.tableName.accessToken,{filter:{token:t[e].token}});o.length||(yield d.commonDB.insertOne(exports.tableName.accessToken,t[e]))}}))}(n.default.posix.join(_,exports.jsonName.accessTokenJson)),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),t=yield F(e);for(let e=0;e<t.length;e++){const{recordList:o}=yield d.commonDB.findByFilter(exports.tableName.uplink,{filter:{name:t[e].name}});o.length||(yield d.commonDB.insertOne(exports.tableName.uplink,t[e]))}}))}(n.default.posix.join(_,exports.jsonName.uplinkJson)),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),i=yield F(e);if(0===i.length)return;if(i.length>1)return void t.OhpmLazyLogger.error('fail to import "uplinkproxy":','Source table "uplinkproxy" can contain only one record.');const{recordList:s}=yield d.commonDB.findByFilter(exports.tableName.uplinkProxy,{});if(s.length&&(s[0].http_proxy||s[0].https_proxy||s[0].no_proxy))return void t.OhpmLazyLogger.warn('import "uplinkproxy" ignored:','Only one record is allowed in the "uplinkproxy" table. Record already exist in the target "uplinkproxy" table.');const a=n.default.posix.join(n.default.dirname(o),exports.jsonName.meta),l=i[0].http_proxy?yield J(i[0].http_proxy,a):"",p=i[0].https_proxy?yield J(i[0].https_proxy,a):"";if(i[0].http_proxy=y.CryptoUtil.encrypt(l),i[0].https_proxy=y.CryptoUtil.encrypt(p),i[0].cryptoVersion=y.CryptoUtil.getVersion(),s.length)return i[0].id=s[0].id,void(yield d.commonDB.updateById(exports.tableName.uplinkProxy,s[0].id,i[0]));yield d.commonDB.insertOne(exports.tableName.uplinkProxy,i[0])}))}(n.default.posix.join(_,exports.jsonName.uplinkProxyJson)),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),i=yield F(e);if(0===i.length)return;if(i.length>1)return void t.OhpmLazyLogger.error('fail to import "repo":','the source table "repo" can contain only one record.');const{recordList:n}=yield d.commonDB.findByFilter(exports.tableName.repo,{});n.length&&n[0].name!==i[0].name?t.OhpmLazyLogger.warn('import "repo" ignored:','Only one record is allowed in the "repo" table. Record already exist in the target "repo" table.'):n.length||(yield d.commonDB.insertOne(exports.tableName.repo,i[0]))}))}(n.default.posix.join(_,exports.jsonName.repoJson)),yield function(o){return e(this,void 0,void 0,(function*(){const e=yield r.FsUtil.readFile(o,"utf-8"),i=yield F(e);if(!i.length)return;const{recordList:n}=yield d.commonDB.findByFilter(exports.tableName.validationConfig,{});if(!n.length)return yield d.commonDB.insertOne(exports.tableName.validationConfig,i[0]),void(yield d.commonDB.insertOne(exports.tableName.validationConfig,i[1]));const s=i.filter((e=>"category"===e.id)),a=i.filter((e=>"repository"===e.id));if("[]"===n[0].configs&&"[]"===n[1].configs)return yield d.commonDB.updateById(exports.tableName.validationConfig,"category",s[0]),void(yield d.commonDB.updateById(exports.tableName.validationConfig,"repository",a[0]));const l=n.filter((e=>"repository"===e.id));if("[]"!==s[0].configs){const e=JSON.parse(s[0].configs).filter((e=>"WhiteList"===e.ruleType))[0].ruleContent;t.OhpmLazyLogger.warn('import "validation_config" ignored:',`The target table contains category whiteList data. Manually set the category whiteList of the oh-package.json5 check rule to "${e}".`)}l[0].configs!==a[0].configs&&t.OhpmLazyLogger.warn('import "validation_config" ignored:','The configuration of the target table is different from source table. Manually configure the oh-package.json5 check rule "Repository Required".')}))}(n.default.posix.join(_,exports.jsonName.validationConfigJson)),t.OhpmLazyLogger.info("data import finished.")}finally{yield r.FsUtil.rm(u,{recursive:!0,force:!0})}}))}(o,c)}catch(e){(0,t.consoleError)(`fail to import userinfo: ${e.message}`)}finally{i.default.shutdown((()=>process.exit(1)))}}))};