"use strict";var e=this&&this.__awaiter||function(e,t,i,r){return new(i||(i=Promise))((function(o,a){function s(e){try{l(r.next(e))}catch(e){a(e)}}function n(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,n)}l((r=r.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.getVerifyName=exports.publishService=exports.PublishService=exports.CHANGELOG_UPPERCASE=exports.CHANGELOG_LOWERCASE=exports.README_UPPERCASE=exports.README_LOWERCASE=void 0;const i=require("../../../utils/CommonConstants"),r=require("./PublishRepository"),o=require("../../group/GroupService"),a=t(require("path")),s=require("../../../utils/FsUtil"),n=require("../../../tools/ssri/Ssri"),l=require("../../../common/FSFactory"),c=require("../../../packages/config/config"),d=require("../../../utils/CommonUtil"),h=require("../../../utils/CompressUtil"),p=require("../../../utils/RandomUtil"),u=require("../../../common"),m=require("../../../common/RepoError"),g=require("../../../common/OHPackageChecker"),y=require("../../../packages/definitions/types"),f=require("../../../common/Constants"),C=require("../../../packages/config/init"),k=require("../../../plugins/cache/CacheFactory"),E=require("../../validator"),v=require("../../../tools/json5"),b=require("../dist-tags/DistTagsService"),P=require("../../../entity/DistTags"),w=require("../../../common/CheckRepoExists"),T=require("../../../tools/db-lock"),N=require("../utils/validateCompability"),S=require("../../cache/CacheService"),D=require("../../../packages/log"),R=require("../../../plugins/storage/calculateHashAndKeepContent"),O=require("../../../utils/extractTargetFiles");exports.README_LOWERCASE="readme.md",exports.README_UPPERCASE="README.md",exports.CHANGELOG_LOWERCASE="changelog.md",exports.CHANGELOG_UPPERCASE="CHANGELOG.md";class A{constructor(){this.cache=k.CacheFactory.createCache(),this.dbCache=k.CacheFactory.createCache({mode:"db"}),this.validator=E.PackageValidatorImpl.getInstance(),this.distTagsService=b.DistTagsService.getInstance()}checkBeforePublish(t,r,o){return e(this,void 0,void 0,(function*(){if(!(yield(0,C.judgeReadWriteMode)()))throw new m.RepoClientError(u.ErrorCode.NoModifyPermission,"mode input is readOnly, can not modify data");const e=`${i.UPLOAD_LOCK_CACHE_PRE}${t}:${r}`;if(yield this.updateUploadLockHourDBCache(e),yield this.dbCache.exists(e))throw new m.RepoClientError(u.ErrorCode.PublishLock,`After unpublishing all versions of the ohpm package, new versions of the same name package are prohibited from being published within ${c.config.upload_lock_hour} hours`);f.GlobalState.isBatchPublishCmdNoCheck||(yield this.timesCheck(o.getId()))}))}publish(t,i,r,o){return e(this,void 0,void 0,(function*(){yield this.checkBeforePublish(t,i,r);const e=new T.DbLock(`${t}:${i}:${this.getVersion(o)}`),a=new T.DbLock(`${t}:${i}`);try{yield e.lock();const s=o&&o.packageType&&o.packageType===f.Constants.HSPPackageType&&o.hspType&&o.hspType===f.HSP_TYPE.BUNDLE_APP?yield this.publishTgz(t,i,r,o):yield this.publishHar(t,i,r,o);try{yield a.lock();const[e,n]=yield this.uploadHarMetaData(s.harParam.fileStorage,s.packageCategory,s.harParam.publishJson,s.harParam.randomTempDir),l=this.genMetaDataPo(s.packageCategory,e);yield this.actionAfterPublish(Object.assign(Object.assign({},s),{metadataPo:l,oldMetaData:n}),t,i,r,o)}finally{yield a.unLock()}}finally{yield e.unLock()}}))}actionAfterPublish(t,o,a,s,n){return e(this,void 0,void 0,(function*(){yield r.publishRepository.saveOrUpdatePackage(t.metadataPo),yield r.publishRepository.savePackageManifest(t.packageCategory),yield r.publishRepository.saveBatchDependencies(t.dependencyPOArr);const e=this.getTag(n);if(e&&e!==b.DistTagsService.ReservedTag){const i=t.packageCategory,r=new P.DistTags(o,a,i.version,e,s.getId());yield this.distTagsService.insertTag(r)}yield this.cache.delete(`${i.METADATA_CACHE_PRE}${o}:${a}`),yield this.deleteOldMetaDataIfNameMismatch(t),f.GlobalState.isBatchPublishCmdNoCheck||(yield this.timesMark(s.getId()))}))}getTgzTempDir(t){return e(this,void 0,void 0,(function*(){const e=d.CommonUtil.genRandomTempDir(),i=this.getVersion(t),r=a.default.resolve(e,`${t.name}-${i}${f.Constants.HAR_SUFFIX}`);yield s.FsUtil.createFileIfNotExists(r);const o=a.default.resolve(e,`${t.name}-${i}${f.Constants.HSP_SUFFIX}`);return yield s.FsUtil.createFileIfNotExists(o),[e,r,o]}))}publishTgz(t,i,r,o){return e(this,void 0,void 0,(function*(){const[e,a,s]=yield this.getTgzTempDir(o),n=yield l.FsFactory.getInstance();try{yield this.verifyPackageType({repoName:t,packageName:i,publishJson:o,randomTempDir:e,fileStorage:n});const l=[],c=yield this.uploadHar({repoName:t,packageName:i,user:r,publishJson:o,harTempDir:a,fileStorage:n,randomTempDir:e});l.push(c);const h=yield this.uploadHsp({repoName:t,packageName:i,user:r,publishJson:o,hspTempDir:s,fileStorage:n});return l.push(h),yield this.mergeResult(l)}finally{yield d.CommonUtil.fsrm(e)}}))}publishHar(t,i,r,o){return e(this,void 0,void 0,(function*(){const e=yield this.genHarTempDir(o);try{yield this.verifyPackageType(Object.assign({repoName:t,packageName:i,publishJson:o},e)),this.dealWithBundleAppTag(o);const s=yield this.uploadHar(Object.assign({repoName:t,packageName:i,user:r,publishJson:o},e));return Object.assign({},s)}finally{yield d.CommonUtil.fsrm(a.default.resolve(e.randomTempDir))}}))}dealWithBundleAppTag(e){if(e.packageType&&e.packageType===f.Constants.HSPPackageType&&!e.hspType){const t=Object.keys(e["dist-tags"]||{});if(1!==t.length)throw new m.RepoClientError(u.ErrorCode.DistTagsQuantityNotMatch,`"pkg ${e.name}" metadata "dist-tags" only has one tag`);const i=e["dist-tags"][t[0]],r=e.versions[i];if(!r)throw new m.RepoClientError(u.ErrorCode.TagVersionNotMatchVersions,`pkg "${e.name}" metadata version of the "dist-tags" recorddoes not match the "versions" record`);r.hspType=f.HSP_TYPE.CROSS_APP}}uploadHar(t){return e(this,void 0,void 0,(function*(){const[e,i]=yield this.checkAndParseBody(t);if(!t.harTempDir){const e=yield this.genHarTempDir(t.publishJson);t=Object.assign(Object.assign({},t),e)}yield this.writeFileToTempDir(t.harTempDir,t.publishJson,e);const r=yield this.verifyAndUploadHar(t.harTempDir,t.publishJson,e,t.fileStorage),o=a.default.join(a.default.dirname(t.harTempDir),"unCompressHar","package","oh-package.json5");return yield(0,N.validateCompability)(t.harTempDir,yield s.FsUtil.readJSON5(o)),{harParam:t,pkgManifest:r,packageCategory:e,dependencyPOArr:i}}))}genHarTempDir(t){return e(this,void 0,void 0,(function*(){const e=d.CommonUtil.genRandomTempDir(),i=this.getVersion(t),r=a.default.resolve(e,`${t.name}-${i}.har`);yield s.FsUtil.createFileIfNotExists(r);return{randomTempDir:e,harTempDir:r,fileStorage:yield l.FsFactory.getInstance()}}))}getPkgCategoryOnHsp(e){const t=this.getVersion(e.publishJson),i=`${e.publishJson.name}-${t}.hsp`,r=this.checkTarBallIntegrity(e.publishJson.versions[t],"integrity_hsp");let o;return o=e.byStream?e.fileSize:this.checkFileSize(e.publishJson,i),{repoName:e.repoName,name:e.packageName,version:t,fileName:i,fileSize:o,checksum:r}}uploadHsp(t){return e(this,void 0,void 0,(function*(){const e=this.getPkgCategoryOnHsp(t);return this.verifyAndUploadHsp(t.hspTempDir,t.publishJson,e,t.fileStorage)}))}mergeResult(t){return e(this,void 0,void 0,(function*(){let e=-1,i=-1;if(t.forEach(((t,r)=>{t.harParam?e=r:i=r})),-1===e||-1===i)throw new Error("fail to merge publish result of .har and .hsp");const r=t[e],o=this.getVersion(r.harParam.publishJson);return r.harParam.publishJson.versions[o].dist.resolved_hsp=t[i].publishJson.versions[o].dist.resolved_hsp,r.harParam.publishJson.versions[o].hspType=r.harParam.publishJson.hspType,r.packageCategory.hspFileId=t[i].packageCategory.hspFileId,Object.assign({},r)}))}genMetaDataPo(e,t){return{id:d.CommonUtil.sha256(`${e.repoName}:${e.name}`),repoName:e.repoName,name:e.name,verifyName:e.verifyName,latestVersion:e.version,groupName:e.groupName,packageType:0,authorId:e.authorId,authorName:e.authorName||"",publisherName:e.publisherName,authorPicUrl:t.authorPicUrl||"",description:e.description||"",keywords:e.keywords,license:e.license,downloads:t.downloads,metaJsonFileId:t.metaJsonFileId,latestPublishTime:e.publishTime,updateTime:e.publishTime}}timesCheck(t){return e(this,void 0,void 0,(function*(){const e=`${i.UPLOAD_TIMES_CACHE_PRE}${t}`,r=yield this.dbCache.get(e);if(!r)return;const o=this.getOneDayAgoHours();if(r.filter((e=>parseInt(e.toString().padEnd(13,"0"))>=o)).length>=c.config.upload_max_times)throw new m.RepoClientError(u.ErrorCode.PublishUploadMaxLimit,`A maximum of ${c.config.upload_max_times} OHPM packages can be uploaded within 24 hours.`)}))}timesMark(t){return e(this,void 0,void 0,(function*(){const e=`${i.UPLOAD_TIMES_CACHE_PRE}${t}`;let r=yield this.dbCache.get(e);if(r){const e=this.getOneDayAgoHours();r=r.filter((t=>parseInt(t.toString().padEnd(13,"0"))>=e))}else r=[];const o=parseInt((new Date).setMinutes(0,0,0).toString().slice(0,8),10);r.push(o),yield this.dbCache.set(e,r,{ttl:i.ONE_DAY_SEC})}))}checkHarStatsAndSum(t,i){return e(this,void 0,void 0,(function*(){const e=yield h.CompressUtil.getFileStat(t);if(i.fileSize!==e.size)throw new m.RepoClientError(u.ErrorCode.InconsistentFileSize,"The actual size of the har file does not match the request.");const r=yield this.calculatedChecksum(t);if(i.checksum!==r)throw new m.RepoClientError(u.ErrorCode.InconsistentChecksum,"The checksum of the har file does not match the request.")}))}writeFileToTempDir(t,i,r){return e(this,void 0,void 0,(function*(){const e=i._attachments[r.fileName].data,o=Buffer.from(e,"base64");yield s.FsUtil.writeFile(t,o)}))}getOneDayAgoHours(){const e=new Date;return e.setMinutes(0,0,0),e.setDate(e.getDate()-1)}verifyAndUploadHar(t,r,o,n){return e(this,void 0,void 0,(function*(){yield this.checkHarStatsAndSum(t,o);const e=a.default.resolve(t,"..");yield h.CompressUtil.verifyFileBoom(t);const l=a.default.join(e,"unCompressHar");yield s.FsUtil.createDirIfNotExists(l),yield s.FsUtil.chmod(l,488),yield s.FsUtil.createDirIfNotExists(l),yield(0,O.extractTargetFiles)(t,l,0,[`package/${i.OH_PACKAGE_JSON}`,`package/${exports.README_LOWERCASE}`,`package/${exports.README_UPPERCASE}`,`package/${exports.CHANGELOG_UPPERCASE}`,`package/${exports.CHANGELOG_LOWERCASE}`]);const c=a.default.join(l,"package");yield this.verifyPackageDir(c,r,o,t);const[d,p]=yield this.findReadmeAndChangeLog(c);this.genTarBall(r,o);const u={repoName:o.repoName,packageName:o.name,version:o.version,isPackage:!1};return yield this.uploadMds([d,p],n,u,o),o.harFileId=yield n.save(t,Object.assign(Object.assign({},u),{isPackage:!0})),o}))}verifyAndUploadHsp(t,i,r,o){return e(this,void 0,void 0,(function*(){const e=i._attachments[r.fileName].data,a=Buffer.from(e,"base64");yield s.FsUtil.writeFile(t,a);const n=yield h.CompressUtil.getFileStat(t);if(r.fileSize!==n.size)throw new m.RepoClientError(u.ErrorCode.InconsistentFileSize,"The actual size of the hsp file does not match the request.");const l=yield this.calculatedChecksum(t);if(r.checksum!==l)throw new m.RepoClientError(u.ErrorCode.InconsistentChecksum,"The checksum of the har hsp does not match the request.");this.genHspTarBall(i,r);const c={repoName:r.repoName,packageName:r.name,version:r.version,isPackage:!1};return r.hspFileId=yield o.save(t,Object.assign(Object.assign({},c),{isPackage:!0})),{publishJson:i,packageCategory:r}}))}uploadMds(t,i,r,o){return e(this,void 0,void 0,(function*(){t[0]&&(o.readmeFileId=yield i.save(t[0],r)),t[1]&&(o.changelogFileId=yield i.save(t[1],r))}))}getLocalMetaData(t,i,o){return e(this,void 0,void 0,(function*(){const e=yield r.publishRepository.selectPackageMetaDataByName(t,i);if(e){let t;try{t=yield o.download(e.metaJsonFileId)}catch(e){throw new m.RepoClientError(u.ErrorCode.downloadDataFail,`fail to download metadata.json file, it's a serious problem, please check whether package"${i}" metadata.json file exists in the file storage center.`,e)}const r=t.toString();return{data:v.JSON5.parse(r),metadataPo:e}}}))}uploadHarMetaData(t,i,r,o){return e(this,void 0,void 0,(function*(){yield s.FsUtil.createDirIfNotExists(o);try{const e=yield this.getLocalMetaData(i.repoName,i.name,t);let n;n=e?this.mergeMetaJson(e.data,r):this.initMetaJson(r);const l=a.default.join(o,"metadata.json");yield s.FsUtil.writeFile(l,JSON.stringify(n,null,2));const c={repoName:i.repoName,packageName:i.name,version:i.version,isPackage:!0},h=yield t.save(l,c);return[{metaJsonFileId:h,authorPicUrl:e&&e.metadataPo?e.metadataPo.authorPicUrl:void 0,downloads:e&&e.metadataPo?e.metadataPo.downloads:0},e]}finally{yield d.CommonUtil.fsrm(o)}}))}initMetaJson(e){const t={},i=Object.keys(e.versions)[0],r=d.CommonUtil.getBeiJingTimeIsoStr();return t._id=e._id,t.name=e.name,t.description=e.description,t.readme=e.readme,t["dist-tags"]=e["dist-tags"],t.versions=e.versions,t.packageType=e.packageType,t._rev="1",t.time={[i]:r,created:r,modified:r},t}mergeMetaJson(e,t){const i=Object.assign({},e),r=Object.keys(t.versions)[0],o=d.CommonUtil.getBeiJingTimeIsoStr();return i.versions=Object.assign(Object.assign({},e.versions),t.versions),i.description=t.description,i.readme=t.readme,i["dist-tags"]=Object.assign(Object.assign({},e["dist-tags"]),t["dist-tags"]),i._rev=""+(+e._rev+1),i.time[r]=o,i.time.modified=o,i}genTarBall(e,t){e.versions[t.version].dist.tarball=`${i.DOWNLOAD_DOMAIN}/${t.repoName}/${t.name}/-/${t.name}-${t.version}.har`}genHspTarBall(e,t){e.versions[t.version].dist.resolved_hsp=`${i.DOWNLOAD_DOMAIN}/${t.repoName}/${t.name}/-/${t.name}-${t.version}.hsp`}findReadmeAndChangeLog(t){return e(this,void 0,void 0,(function*(){let e,i;const r=yield s.FsUtil.readdir(t);for(const o of r){if(o.toLowerCase()===exports.README_LOWERCASE&&(e=a.default.join(t,o),0===(yield h.CompressUtil.getFileStat(e)).size))throw new m.RepoClientError(u.ErrorCode.InvalidReadmeFileSize,"The size of the readme.md file cannot be 0.");if(o.toLowerCase()===exports.CHANGELOG_LOWERCASE&&(i=a.default.join(t,o),0===(yield h.CompressUtil.getFileStat(i)).size))throw new m.RepoClientError(u.ErrorCode.InvalidChangelogFileSize,"The size of the changelog.md file cannot be 0.")}return[e,i]}))}verifyPackageDir(t,r,o,n){return e(this,void 0,void 0,(function*(){if(!(yield s.FsUtil.exists(t)))throw new m.RepoClientError(u.ErrorCode.PackageDirNotExist,"Package dir does not exist");const e=a.default.join(t,"oh-package.json5");if(!(yield s.FsUtil.exists(e)))throw new m.RepoClientError(u.ErrorCode.OhPackageJson5FileNotExist,"oh-package.json5 does not exist");const l=yield s.FsUtil.readJSON5(e),c=r.versions[o.version];g.OHPackageChecker.dealArtifactType(l),g.OHPackageChecker.dealArtifactType(l);for(const e of i.OHPM_PACKAGE_JSON5_KEYS_ARR)if(JSON.stringify(c[e])!==JSON.stringify(l[e]))throw new m.RepoClientError(u.ErrorCode.InconsistentKey,`The oh-package.json5 value of ${e} does not match the request.`);yield g.OHPackageChecker.ensureValidPackageFile(t,l,n)}))}calculatedChecksum(t){return e(this,void 0,void 0,(function*(){let e;try{return e=yield(0,R.calculateHashAndKeepContent)(s.FsUtil.createReadStream(t),"sha512"),e.hash}catch(e){throw new m.RepoClientError(u.ErrorCode.CalculatedChecksumFailed,"Fail to calculate checksum!",e)}finally{e&&e.contentStream&&e.contentStream.destroy()}}))}calculatedChecksumByBuffer(e){try{const t=n.ssri.fromData(e);return n.ssri.parse(t.getIntegrity()).toString()}catch(e){throw new m.RepoClientError(u.ErrorCode.CalculatedChecksumFailed,"Fail to calculate checksum!",e)}}checkAndParseBody(t){return e(this,void 0,void 0,(function*(){if(!(yield(0,w.checkRepoExists)(t.repoName)))throw new m.RepoClientError(u.ErrorCode.RepoNotFound,`The repository ${t.repoName} does not exist!`);const{name:e,group:i,version:r,packageJson:o,keywords:a,checksum:s,fileName:n,fileSize:l,dependencies:c,devDependencies:h,dynamicDependencies:p}=yield this.checkPublishJson(t);return[{id:d.CommonUtil.sha256(`${t.repoName}:${e}:${r}`),repoName:t.repoName,name:e,verifyName:F(e),version:r,groupName:i,status:0,packageType:0,authorId:t.user.getId(),authorName:o.author.name||"",publisherName:t.user.getName()||"",authorUrl:o.author.url||"",authorEmail:o.author.email||"",description:o.description||"",keywords:a,homepage:o.homepage,repository:o.repository,license:o.license,artifactType:o.artifactType,checksum:s,fileName:n,fileSize:l,fileNum:0,readmeFileId:"",changelogFileId:"",harFileId:"",hspFileId:"",publishJsonFileId:"",publishTime:Date.now(),unPublishTime:0,updateTime:0},[...c,...h,...p]]}))}checkPublishJson(t){return e(this,void 0,void 0,(function*(){this.nameConsistencyCheck(t);const e=yield this.nameDuplicationCheck(t.repoName,t.packageName,t.user),i=yield this.checkGroup(t.packageName,t.user),r=yield this.checkVersion(t.repoName,t.packageName,t.publishJson);yield this.checkTag(t.repoName,t.packageName,t.publishJson);const o=t.publishJson.versions[r];g.OHPackageChecker.dealAuthorField(o),g.OHPackageChecker.dealArtifactType(o),yield this.validator.validate(o);const a=this.checkKeywords(o),s=this.checkTarBallIntegrity(o,"integrity"),n=this.checkFileName(o);let l;l=t.byStream?t.fileSize:this.checkFileSize(t.publishJson,n);return{name:e,group:i,version:r,packageJson:o,keywords:a,checksum:s,fileName:n,fileSize:l,dependencies:this.getDependencies(t.repoName,e,r,o.dependencies,y.DepType.NORMAL),devDependencies:this.getDependencies(t.repoName,e,r,o.devDependencies,y.DepType.DEV),dynamicDependencies:this.getDependencies(t.repoName,e,r,o.dynamicDependencies,y.DepType.DYNAMIC)}}))}nameConsistencyCheck(e){if(e.packageName!==e.publishJson.name)throw new m.RepoClientError(u.ErrorCode.InconsistentPackageName,"The path.name is no equals requestBody.name!")}checkFileName(e){const t=`${e.name}-${e.version}.har`;if(t.length>255)throw new m.RepoClientError(u.ErrorCode.InvalidFileName,`The package filename "${t}" is too long!`);return t}verifyPackageType(t){return e(this,void 0,void 0,(function*(){const e=yield this.getLocalMetaData(t.repoName,t.packageName,t.fileStorage);if(e&&e.data&&t.publishJson.packageType!==e.data.packageType)throw e.data.packageType?new m.RepoClientError(u.ErrorCode.OHPMPackageType,"The packageType is no equals the exists packageType!"):new m.RepoClientError(u.ErrorCode.OHPMPackageType,"Do not support change a har package to a hsp package!")}))}nameDuplicationCheck(t,i,o){return e(this,void 0,void 0,(function*(){if(yield r.publishRepository.hasSimilarityNameExists(t,i))throw new m.RepoClientError(u.ErrorCode.SimilarityPackageExists,`Package name "${i}" is duplicate when hyphen(-), dots(.), and underscores(_) are removed.`);if(yield r.publishRepository.hasSamePackageExists(t,i,o))throw new m.RepoClientError(u.ErrorCode.SamePackageExists,`Publish package without group can only be done by the same user, package named "${i}" has already been published by another user!`);return i}))}checkGroup(t,i){return e(this,void 0,void 0,(function*(){if(!t.startsWith("@"))return null;const e=t.split("/")[0].replace("@","");if(!(yield o.groupService.exists(e)))throw new m.RepoClientError(u.ErrorCode.GroupNotExist,`Group "${e}" does not exist!`);if(!f.GlobalState.isBatchPublishCmdNoCheck&&i.getIsAuthPlugin()&&!(yield o.groupService.isMemberByAuthPlugin(e,i)))throw new m.RepoClientError(u.ErrorCode.NotMember,`You are not a member of the group "${e}"!`);if(!i.getIsAuthPlugin()&&!(yield o.groupService.isMember(e,i.getId())))throw new m.RepoClientError(u.ErrorCode.NotMember,`You are not a member of the group "${e}"!`);return e}))}checkVersion(t,i,o){return e(this,void 0,void 0,(function*(){const e=this.getVersion(o);if(!e)throw new m.RepoClientError(u.ErrorCode.InvalidVersionSize,"Publishing versions is greater than one.");const a=yield r.publishRepository.findSameVersionAndNamePackage(t,i,e);if(0===a.total)return e;throw parseInt(a.recordList[0].unPublishTime)?new m.RepoClientError(u.ErrorCode.VersionUnpublish,`The package "${i}@${e}" was once published, but has been unpublished, please change the package version and publish it again.`):new m.RepoClientError(u.ErrorCode.VersionExist,`The package "${i}@${e}" already exists.`)}))}checkTag(t,i,r){return e(this,void 0,void 0,(function*(){const e=this.getTag(r);yield this.distTagsService.validPublishTag(e,t,i)}))}getTag(e){const t=e["dist-tags"]||{},i=Object.keys(t);if(i.length>0)return i[0]}checkKeywords(e){const t=e.keywords;if(!t)return null;if(!Array.isArray(t))throw new m.RepoClientError(u.ErrorCode.EachKeywordTypeError,"Keywords parse array error!");let r=0;const o=new Set;for(const e of t){if("string"!=typeof e)throw new m.RepoClientError(u.ErrorCode.EachKeywordTypeError,`Keyword is not string: ${JSON.stringify(e)}!`);if(++r>10)throw new m.RepoClientError(u.ErrorCode.InvalidKeywords,"The number of keywords cannot exceed 10!");if(!i.KEYWORD_REGEX.test(e))throw new m.RepoClientError(u.ErrorCode.InvalidKeywords,`Invalid keyword: ${e}`);if(o.add(e),o.size!==r)throw new m.RepoClientError(u.ErrorCode.DuplicateKeywords,`Duplicate keywords: ${e}`)}return[...o].join(",")}getVersion(e){const t=e.versions,i=Object.keys(t);if(!(i.length>1))return i[0]}checkTarBallIntegrity(e,t){if(!e.dist||!e.dist[t])throw new m.RepoClientError(u.ErrorCode.ChecksumEmptyError,`"${t}" cannot be empty!`);const i=e.dist[t];if("string"!=typeof i||!i.startsWith("sha512-")||i.length>128)throw new m.RepoClientError(u.ErrorCode.InvalidChecksum,`Invalid "${t}"!`);return i}checkFileSize(e,t){if(!e._attachments||!e._attachments[t]||!e._attachments[t].length)throw new m.RepoClientError(u.ErrorCode.FileEmptyError,"File size is null!");const i=e._attachments[t].length;return this.judgeFileSize(i),i}judgeFileSize(e){if("number"!=typeof e||e>c.config.max_package_size*(1<<20))throw new m.RepoClientError(u.ErrorCode.ExceedPackageSize,`The size of the OHPM package file is 0 or exceeds ${c.config.max_package_size}MB`)}getDependencies(e,t,i,r,o){const a=[];if(!r)return a;const s=Object.keys(r);for(const n of s){const s=r[n];a.push({id:d.CommonUtil.sha256(`${e}:${t}:${i}${p.RandomUtil.generateSecureRandomString(16)}`),repoName:e,name:t,version:i,depPackageName:n,depPackageVersion:s,depType:o})}return a}deleteOldMetaDataIfNameMismatch(t){return e(this,void 0,void 0,(function*(){t.oldMetaData&&t.oldMetaData.metadataPo&&t.oldMetaData.metadataPo.metaJsonFileId!==t.metadataPo.metaJsonFileId&&(yield t.harParam.fileStorage.delete(t.oldMetaData.metadataPo.metaJsonFileId))}))}updateUploadLockHourDBCache(t){return e(this,void 0,void 0,(function*(){const e=yield S.cacheService.findCacheDataByKey(t);if(e&&e.options){const i=JSON.parse(e.options);if(i.ttl&&3600*c.config.upload_lock_hour!==i.ttl){const i={ttl:3600*c.config.upload_lock_hour};yield S.cacheService.addCache(t,1,i,e.createTime),D.OhpmLazyLogger.debug(`update DBCache with key "${t}".`)}}}))}}function F(e){if(!e)return e;if(e.startsWith("@")){const t=e.split("/");return`${t[0]}/${t[1].replace(/[-_.]/g,"")}`}return e.replace(/[-_.]/g,"")}exports.PublishService=A,exports.publishService=new A,exports.getVerifyName=F;