"use strict";var t=this&&this.__awaiter||function(t,e,i,o){return new(i||(i=Promise))((function(r,n){function s(t){try{l(o.next(t))}catch(t){n(t)}}function c(t){try{l(o.throw(t))}catch(t){n(t)}}function l(t){var e;t.done?r(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(s,c)}l((o=o.apply(t,e||[])).next())}))},e=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Crypto=exports.createKey=exports.validKey=exports.initKeys=exports.loadCustomKeys=void 0;const i=require("../log"),o=require("./base"),r=e(require("path")),n=require("../../utils/FsUtil"),s=require("crypto"),c=require("../../common/Constants"),l=require("./CommonUtil"),d=require("../config/init"),a=require("../config/config"),y=require("../../common/DbAndStoreType"),u=require("../../utils/FsBlockingUtil");function f(e){return t(this,void 0,void 0,(function*(){const t=h(e),i=m(r.default.join(e,"ac")),n=o.RootKeyUtil.newInstance256(t[0],t[1],t[2],i),s=m(r.default.join(e,"ce"));return(0,l.isValidStr)(o.WorkKeyCryptUtil.decryptWorkKey(s,n))}))}function p(e){return t(this,void 0,void 0,(function*(){if(i.OhpmLazyLogger.debug("begin to create new key files."),(yield n.FsUtil.exists(e))&&0!==(yield n.FsUtil.readdir(e)).length)return void i.OhpmLazyLogger.warn("cannot create crypto directory, target crypto directory already exist.");yield n.FsUtil.createDirIfNotExists(r.default.join(e)),yield n.FsUtil.chmod(r.default.join(e),448);const c=r.default.join(e,"fd"),l=yield w(r.default.join(c,"0"),128),d=yield w(r.default.join(c,"1"),128),a=yield w(r.default.join(c,"2"),128),y=yield w(r.default.join(e,"ac"),16),u=o.RootKeyUtil.newInstance256(l,d,a,y),f=o.CommCryptUtil.byte2HexStr(o.CommCryptUtil.genSecureRandomByte(16)),p=o.WorkKeyCryptUtil.encryptWorkKey(f,u);yield function(e,i){return t(this,void 0,void 0,(function*(){const t=(0,s.createHash)("sha256").update(e).digest("hex");yield n.FsUtil.createDirIfNotExists(i);const o=r.default.join(i,t+".txt");yield n.FsUtil.writeFile(o,e),yield n.FsUtil.chmod(o,256)}))}(p,r.default.join(e,"ce")),yield function(e){return t(this,void 0,void 0,(function*(){const t=(new Date).getTime().toString(),i=r.default.join(e,"version.txt");yield n.FsUtil.writeFile(i,t),yield n.FsUtil.chmod(i,256)}))}(e)}))}function h(t){const e=r.default.join(t,"fd");if(!u.FsBlocking.existsSync(e))throw new Error("invalid crypto component");if(3!==u.FsBlocking.readdirSync(e).length)throw new Error("invalid crypto component");return[m(r.default.join(t,"fd","0")),m(r.default.join(t,"fd","1")),m(r.default.join(t,"fd","2"))]}function m(t){if(!u.FsBlocking.existsSync(t))throw new Error("invalid crypto component");const e=u.FsBlocking.readdirSync(t);if(1!==e.length)throw new Error("invalid crypto component");const i=e[0];if(!i.endsWith(".txt"))throw new Error("invalid crypto component");const o=u.FsBlocking.readFileSync(r.default.join(t,i),"utf-8");if((0,s.createHash)("sha256").update(o).digest("hex")!==i.slice(0,-4))throw new Error("invalid crypto component");return o}function g(e){return t(this,void 0,void 0,(function*(){if(yield n.FsUtil.exists(e)){const t=yield n.FsUtil.readdir(e);if(3===t.length||4===t.length)return!0;if(0===t.length)return!1;throw new Error("invalid crypto component")}return!1}))}function w(e,i){return t(this,void 0,void 0,(function*(){const t=o.CommCryptUtil.byte2HexStr(o.CommCryptUtil.genSecureRandomByte(i)),c=(0,s.createHash)("sha256").update(t).digest("hex");yield n.FsUtil.createDirIfNotExists(r.default.join(e));const l=r.default.join(e,c+".txt");return yield n.FsUtil.writeFile(l,t),yield n.FsUtil.chmod(l,256),t}))}exports.loadCustomKeys=function(e){return t(this,void 0,void 0,(function*(){let t;try{if(!e)return null;const i=r.default.resolve(process.cwd(),e);if(!(yield g(i))||!(yield f(i)))throw new Error("invalid crypto path");return t=new v(i),t}catch(t){throw i.OhpmLazyLogger.error(`fail to load encryption component: ${t}`),new Error("custom crypto error")}}))},exports.initKeys=function(e){return t(this,void 0,void 0,(function*(){const t=r.default.join(c.Constants.DATA_DIR,c.Constants.KEY_DIR_NAME);try{if(yield g(t)){if(!(yield f(t)))throw new Error("meta file is damaged.")}else yield p(t);a.config.db.type===y.DbType.Mysql&&(yield(0,d.encryptYamlMysqlPassword)(e),a.config.store.type===y.StorageType.Sftp&&(yield(0,d.encryptYamlSftpPassword)(e))),i.OhpmLazyLogger.info("initialize encryption component successfully.")}catch(t){throw new Error(`fail to initialize encryption component: ${t}`)}}))},exports.validKey=f,exports.createKey=p;class v{constructor(t){if(!g(t))throw new Error("invalid crypto component");this.cryptoPath=t;const e=h(t),i=m(r.default.join(t,"ac"));this.rootKey=o.RootKeyUtil.newInstance256(e[0],e[1],e[2],i),this.encWorkKey=m(r.default.join(t,"ce")),this.loadCryptoVersion(this.cryptoPath)}loadCryptoVersion(t){const e=r.default.join(t,"version.txt");u.FsBlocking.existsSync(e)?this.cryptoVersion=u.FsBlocking.readFileSync(e,"utf-8"):this.cryptoVersion=""}getRootKey(){return this.rootKey}getEncWorkKey(){return this.encWorkKey}destroy(){this.rootKey=null,this.encWorkKey=null}getCryptoPath(){return this.cryptoPath}getCryptoVersion(){return this.cryptoVersion}}exports.Crypto=v;