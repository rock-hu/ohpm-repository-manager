"use strict";var e=this&&this.__createBinding||(Object.create?function(e,r,t,i){void 0===i&&(i=t);var o=Object.getOwnPropertyDescriptor(r,t);o&&!("get"in o?!r.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return r[t]}}),Object.defineProperty(e,i,o)}:function(e,r,t,i){void 0===i&&(i=t),e[i]=r[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),t=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var i={};if(null!=t)for(var o in t)"default"!==o&&Object.prototype.hasOwnProperty.call(t,o)&&e(i,t,o);return r(i,t),i},i=this&&this.__awaiter||function(e,r,t,i){return new(t||(t=Promise))((function(o,n){function c(e){try{u(i.next(e))}catch(e){n(e)}}function l(e){try{u(i.throw(e))}catch(e){n(e)}}function u(e){var r;e.done?o(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(c,l)}u((i=i.apply(e,r||[])).next())}))},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.publicKeyService=void 0;const n=require("./PublicKeyRepository"),c=require("../../entity/PublicKey"),l=o(require("node-forge")),u=require("../../common/RepoError"),y=require("../../common"),s=require("../../common/CommonValidator"),p=require("../../packages/log"),a=require("../user/UserService"),d=require("../../utils/CryptoUtil"),h=t(require("crypto")),b=require("../system/KeyManageService"),f=require("../../tools/sshPublicKeyToPEM");function K(e){return i(this,void 0,void 0,(function*(){let r;try{if(r=yield d.CryptoUtil.decrypt(e.publicKey,e.cryptoVersion),!r)throw new u.RepoClientError(y.ErrorCode.InvalidEncryptionComponent,"Fail to decrypt publicKey")}catch(e){throw new u.RepoClientError(y.ErrorCode.InvalidEncryptionComponent,"Fail to decrypt publicKey",e)}return{id:e.id,name:e.name,createTime:e.createTime,publicKey:r,publishId:e.publishId}}))}class E{static getInstance(){return this.Instance||(this.Instance=new E,b.keyManageService.subscribeReEncryptEvent(this.Instance)),this.Instance}constructor(){}addPublicKey(e,r){return i(this,void 0,void 0,(function*(){s.CommonValidator.checkUUID(e);const t=yield a.userService.getUserByUserId(e);if(!t)throw new u.RepoClientError(y.ErrorCode.UserNotExist,"Incorrect user name or password.");const i=yield n.publicKeyRepository.findByFilter(e);if(i.total>=10)throw new u.RepoClientError(y.ErrorCode.PublicKeyCountError,"current user can have a maximum of 10 records.");i.recordList.forEach((e=>{if(r.name===e.name)throw p.OhpmLazyLogger.error("name already exist."),new u.RepoClientError(y.ErrorCode.PublicKeyNameError,"name already exist.")}));const o=new c.PublicKey(r,t);if(this.getPublicKey(o.publicKey)<4096)throw p.OhpmLazyLogger.error("the length of the public key cannot be less than 4096 bits."),new u.RepoClientError(y.ErrorCode.InvalidPublicKeyError,"The length of the ohpm public key cannot be less than 4096 bits.");let l;try{if(l=d.CryptoUtil.encrypt(o.publicKey),!l)throw new u.RepoClientError(y.ErrorCode.InvalidEncryptionComponent,"Fail to encrypt publicKey")}catch(e){throw new u.RepoClientError(y.ErrorCode.InvalidEncryptionComponent,"Fail to encrypt publicKey",e)}return o.publicKey=l,o.cryptoVersion=d.CryptoUtil.getVersion(),n.publicKeyRepository.insert(o)}))}addPublicKeyInner(e){return i(this,void 0,void 0,(function*(){return n.publicKeyRepository.insert(e)}))}delPublicKeyById(e,r){return i(this,void 0,void 0,(function*(){s.CommonValidator.checkUUID(e);if(0===(yield n.publicKeyRepository.findPublicKey(e,r)).total)throw new u.RepoClientError(y.ErrorCode.UserNotMatch,"The user and public key do not match.");return n.publicKeyRepository.deleteById(e)}))}getPublicKeyList(e){return i(this,void 0,void 0,(function*(){const r=yield this.getEncryptedPublicKeyList(e),t=[],i=r.total;for(const e of r.recordList)t.push(yield K(e));return{total:i,recordList:t}}))}getEncryptedPublicKeyList(e){return i(this,void 0,void 0,(function*(){return s.CommonValidator.checkUUID(e),n.publicKeyRepository.findByFilter(e)}))}getPublicKeysByPublishId(e){return i(this,void 0,void 0,(function*(){const r=yield n.publicKeyRepository.findByPublishIdFilter(e),t=[];for(const e of r.recordList)t.push(yield K(e));return t}))}getPublicKey(e){if(e.startsWith("ssh-rsa "))return this.getPKCS8PublicKey(e);if(e.startsWith("-----BEGIN PUBLIC KEY-----")&&e.endsWith("-----END PUBLIC KEY-----"))return this.getPemPublicKey(e);throw new u.RepoClientError(y.ErrorCode.InvalidPublicKeyError,"PublicKey Type Error.")}getPKCS8PublicKey(e){try{return l.default.pki.publicKeyFromPem((0,f.sshPublicKeyToPEM)(e)).n.bitLength()}catch(e){throw new u.RepoClientError(y.ErrorCode.InvalidPublicKeyError,"Validate PKCS8 PublicKey Error.")}}getPemPublicKey(e){try{return l.default.pki.publicKeyFromPem(e).n.bitLength()}catch(e){throw new u.RepoClientError(y.ErrorCode.InvalidPublicKeyError,"Validate PEM PublicKey Error.")}}verifySign(e,r,t){const i=(0,f.sshPublicKeyToPEM)(e),o=h.createVerify("RSA-SHA256");return o.update(r),o.verify(i,t,"base64")}reEncrypt(e){return i(this,void 0,void 0,(function*(){yield this.reEncryptByUserPage(1,100,e)}))}reEncryptByUserPage(e,r,t){return i(this,void 0,void 0,(function*(){const i=yield a.userService.getUserList(e,r);if(i){const e=[];for(const r of i.recordList)e.push(this.reEncryptPublicKey(r.id,t));yield Promise.all(e)}100===i.length?(e++,yield this.reEncryptByUserPage(e,r,t)):p.OhpmLazyLogger.info("re-encrypt finish, no more user!")}))}reEncryptPublicKey(e,r){return i(this,void 0,void 0,(function*(){const t=yield exports.publicKeyService.getEncryptedPublicKeyList(e);p.OhpmLazyLogger.info(`begin to re-encrypt publicKey, size: ${t.total}.`);const i=t.recordList;for(const t of i)try{if(t.cryptoVersion===r.getCryptoVersion())continue;const i=yield d.CryptoUtil.decrypt(t.publicKey,t.cryptoVersion),o=b.keyManageService.encrypt(i,r);if(!o)throw new u.RepoClientError(y.ErrorCode.InvalidEncryptionComponent,"Fail to re-encrypt publicKey");t.publicKey=o,t.userId=e,t.cryptoVersion=r.getCryptoVersion(),yield exports.publicKeyService.delPublicKeyById(t.id,e),yield exports.publicKeyService.addPublicKeyInner(t)}catch(e){throw p.OhpmLazyLogger.error(`fail to re-encrypt publicKey: ${e.message}.`),new u.RepoClientError(e.code,e.message)}p.OhpmLazyLogger.info("re-encrypt publicKey succeed.")}))}}exports.publicKeyService=E.getInstance();