"use strict";var e=this&&this.__awaiter||function(e,t,i,r){return new(i||(i=Promise))((function(o,a){function n(e){try{l(r.next(e))}catch(e){a(e)}}function s(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(n,s)}l((r=r.apply(e,t||[])).next())}))},t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.repoService=exports.checkFileName=void 0;const i=require("./RepoRepository"),r=require("../../entity/Repo"),o=require("../../packages/config/config"),a=require("../../common/CommonValidator"),n=require("../uplinks/UplinkRepository"),s=require("../../utils/RandomUtil"),l=require("../../common/RepoError"),d=require("../../common"),c=require("../../utils/PageUtil"),h=t(require("path")),p=require("../../utils/FsUtil"),u=require("../../utils/CommonConstants"),f=require("./UploadPackageVO"),g=require("../../tools/ssri/Ssri"),y=require("../client/publish/PublishStreamService"),m=require("../client/publish/PublishService"),v=require("../../packages/log"),k=require("../package/PackageRepository"),P=require("../../utils/CompressUtil"),I=require("../../common/Constants"),C=require("../../utils/CommonUtil"),w=require("../client/unpublish/UnPublishService"),E=require("../client/login/OhUserInfo"),U=t(require("tar")),R=require("./FileInfo"),F=require("../../common/ErrorCode"),b=require("../validator"),S=require("../../common/OHPackageChecker"),N=require("../client/utils/validateCompability"),_=require("./PackageDataSearchFilter"),D=t(require("semver")),T=require("../client/unpublish/UnPublishBO"),A=require("../user/UserService"),B=require("../client/unpublish/UnPublishRepository"),H=/^[^\\/:*?'<>|]+$/;function O(e,t,i=!1){const r={_id:e.name,name:e.name,packageType:e.packageType,description:e.description,"dist-tags":{},versions:{}};r.versions[e.version]=e;const o=e.tag||"latest";r["dist-tags"][o]=e.version;const a=`${e.name}-${e.version}.har`,n=`${e.name}/-/${a}`,s=g.ssri.fromData(t);return e._id=`${e.name}@${e.version}`,e.dist=Object.assign({},e.dist),e.dist.integrity=s.getIntegrity(),e.dist.tarball=new URL(n,C.CommonUtil.getServerAddress()).href,i||(r._attachments={},r._attachments[a]={content_type:"application/octet-stream",data:t.toString("base64"),length:t.length}),r}function q(t){return e(this,void 0,void 0,(function*(){a.CommonValidator.checkUUID(t);const e=yield i.repoRepository.findById(t);if(!e)throw new l.RepoClientError(d.ErrorCode.RepoNotFound,`Can't find repo whose id is ${t}`);return new r.Repo(e)}))}function $(e){if(e&&e.fileName&&!H.test(e.fileName))throw new l.RepoClientError(d.ErrorCode.InvalidRepoFileName,F.MESSAGE_CN[d.ErrorCode.InvalidRepoFileName])}function x(t,i,r,a=!1){return e(this,void 0,void 0,(function*(){if(function(e){if("application/octet-stream"!==e.mimetype||!e.fileName.endsWith(".har")&&!e.fileName.endsWith(".tgz"))throw new l.RepoClientError(d.ErrorCode.PackageTypeError,"Only .har files are allowed");if(e.size>o.config.max_package_size*(1<<20))throw new l.RepoClientError(d.ErrorCode.ExceedPackageSize,`Total file size is more than ${o.config.max_package_size} MB.`)}(t),yield P.CompressUtil.verifyFileBoom(t.path),yield p.FsUtil.createDirIfNotExists(i),yield p.FsUtil.chmod(i,488),U.default.extract({file:t.path,cwd:i,strip:0,sync:!0},[`package/${u.OH_PACKAGE_JSON}`]),a){const e=h.default.join(i,"package",u.OH_PACKAGE_JSON);yield(0,N.validateCompability)(t.path,yield p.FsUtil.readJSON5(e))}const n=h.default.join(i,"package"),s=yield function(t){return e(this,void 0,void 0,(function*(){let e={name:"",version:"",dependencies:[],children:[]};const i=h.default.join(t,u.OH_PACKAGE_JSON);if(!(yield p.FsUtil.exists(i)))throw new l.RepoClientError(d.ErrorCode.OhPackageJson5FileNotExist,`${u.OH_PACKAGE_JSON} not exist.`);return e=yield p.FsUtil.readJSON5(i),S.OHPackageChecker.dealArtifactType(e),S.OHPackageChecker.dealAuthorField(e),e._nodeVersion=process.versions.node,e._ohpmVersion=`ohpm-repo-${I.Constants.VERSION}`,e}))}(n);return yield r.validate(s),s}))}function z(e){if(!e)throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,"unPublish packageIds is invalid.");if(!Array.isArray(e))throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,"unPublish packageIds must be array.");if(e.length<1||e.length>T.UnPublishBO.BATCH_UN_PUBLISH_MAX_PACKAGE_NUM)throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,`unPublish packageIds length must be between 1 and ${T.UnPublishBO.BATCH_UN_PUBLISH_MAX_PACKAGE_NUM}.`);if(!e.every((e=>"string"==typeof e)))throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,"unPublish packageIds must be string array.")}function M(e){return{id:e.id,name:e.name,author:e.authorName,publisherName:e.publisherName,version:e.version,description:e.description,license:e.license,keywords:e.keywords,status:e.status,publishTime:e.publishTime}}exports.checkFileName=$,exports.repoService=new class{constructor(){this.validator=b.PackageValidatorImpl.getInstance()}getPackageWithAllVersionList(t,i,r){return e(this,void 0,void 0,(function*(){const e=r.getCurrentPage(),o=r.getPageSize(),a=yield q(i);let n=new _.PackageDataSearchFilter(t).getFilterPackage();n=Object.assign(Object.assign(Object.assign({},n),{repoName:a.getName()}),{status:u.PackageStatus.Published});let s,l=[];const d=t.packageMinVersion,h=t.packageMaxVersion;if((d||h)&&this.isVersionValid(d,h)){const e=yield this.getPackageListByFilterWithoutVersion(n),i=this.filterAgainByVersion(e,t);s=i.length;const o=(r.getCurrentPage()-1)*r.getPageSize();l=[...i].slice(o,o+r.getPageSize())}else{const t=yield k.packageRepository.getPackageListByFilter(e,o,n);for(const e of t.recordList)l.push(M(e));s=t.total}return c.PageUtil.formPage(s,r.getCurrentPage(),r.getPageSize(),l)}))}updateRepo(t,r){return e(this,void 0,void 0,(function*(){const e=yield q(r.getId());if(e.getName()!==r.getName()){const t=yield k.packageRepository.findByFilter({repoName:e.getName(),status:u.PackageStatus.Published});if(t&&t.total>0)throw new l.RepoClientError(d.ErrorCode.Referenced,`The repo name ${e.getName()} cannot be modified if it contains any packages`)}if(r.getUplink()){const e=yield n.uplinkRepository.getList({name:r.getUplink()});if(!e||e.total<=0)throw new l.RepoClientError(d.ErrorCode.UplinkNotFound,`Can't find uplink whose name is ${r.getUplink()}.`)}yield i.repoRepository.updateById(r),v.OhpmLazyLogger.info("update repo success:",`repo's id is ${r.getId()}.`)}))}analyzePackage(t,r){return e(this,void 0,void 0,(function*(){yield function(t){return e(this,void 0,void 0,(function*(){a.CommonValidator.checkUUID(t);if(!(yield i.repoRepository.findById(t)))throw new l.RepoClientError(d.ErrorCode.RepoNotFound,`Can't find repo whose id is ${t}`)}))}(t),$(r);const o=this.isTgzFile(r.fileName),n=r.path,s=yield this.genCacheDir();let c=s;try{if(o){const e=yield C.CommonUtil.hspDetect(r.path);C.CommonUtil.validHspDetectResult(e),yield p.FsUtil.createDirIfNotExists(s),yield p.FsUtil.chmod(s,488),U.default.extract({file:r.path,cwd:s,strip:0,sync:!0},[e.interfaceHar,e.hsp]),r=this.changeFileInfo(e.interfaceHar,s,r);const t=h.default.resolve(s,e.interfaceHar.split(".")[0]);yield p.FsUtil.createDirIfNotExists(t),c=t}const e=yield x(r,c,this.validator,!0);return e.author=e.author.name,e.keywords&&(e.keywords=e.keywords.join(",")),new f.UploadPackageVO(e)}finally{yield this.removeAnalyzeCache(o,n,s,r)}}))}validateBeforeUploadPkg(t){return e(this,void 0,void 0,(function*(){const e=yield q(t.repoId);$(t.fileInfo);const i=b.PackageValidatorImpl.getInstance(),r=JSON.parse(JSON.stringify(t.uploadPackageInfo));r.keywords&&!Array.isArray(r.keywords)&&(r.keywords=r.keywords.split(",")),yield i.validate(r,["name","version","description","license","keywords","author"]);const o=yield this.genCacheDir();return yield p.FsUtil.createDirIfNotExists(o),yield p.FsUtil.chmod(o,488),{repo:e,cacheDir:o}}))}uploadPackage(t){return e(this,void 0,void 0,(function*(){const{repo:e,cacheDir:i}=yield this.validateBeforeUploadPkg(t);this.isTgzFile(t.fileInfo.fileName)?yield this.uploadTgz(e,t,i):yield this.uploadHar(e,t,i)}))}uploadPackageByStream(t){return e(this,void 0,void 0,(function*(){const{repo:e,cacheDir:i}=yield this.validateBeforeUploadPkg(t);this.isTgzFile(t.fileInfo.fileName)?yield this.uploadTgzByStream(e,t,i):yield this.uploadHarByStream(e,t,i)}))}uploadHarByStream(t,i,r){return e(this,void 0,void 0,(function*(){try{const e=yield this.genHarMetaDataByStream(i,r),o={metadata:JSON.stringify(e),pkg_stream:i.fileInfo};yield y.publishStreamService.publish(t.getName(),e.name,i.user,o)}finally{yield this.removeUploadCache(i.fileInfo.path,r)}}))}chmodUploadTempDir(){return e(this,void 0,void 0,(function*(){try{yield p.FsUtil.createDirIfNotExists(h.default.join(I.Constants.DATA_DIR,"temp","uploads")),yield p.FsUtil.chmod(h.default.join(I.Constants.DATA_DIR,"temp"),488),yield p.FsUtil.chmod(h.default.join(I.Constants.DATA_DIR,"temp","uploads"),488)}catch(e){v.OhpmLazyLogger.error("temporary folder permissions fail to be assigned.")}}))}getPackageSizeLimit(){return{packageSize:o.config.max_package_size}}unPublish(t,i){return e(this,void 0,void 0,(function*(){const e=new E.OhUserInfo({id:t}),r=yield k.packageRepository.getManifestById(i);if(!r)throw new l.RepoClientError(d.ErrorCode.PackageNotExist,"The package does not exist!");yield w.unPublishService.unPublish(r.repoName,r.name,r.version,e,!0)}))}batchUnPublish(t,i){return e(this,void 0,void 0,(function*(){const e=new E.OhUserInfo({id:t});z(i);const r=yield k.packageRepository.getManifestByIds(i);if(r.total!==i.length)throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,"unPublish packageIds has no corresponding package.");const o=r.recordList.map((e=>({repoName:e.repoName,packageName:e.name,version:e.version})));yield w.unPublishService.batchUnPublish(o,e,!0)}))}checkBatchUnPublish(t,i){return e(this,void 0,void 0,(function*(){const r=new E.OhUserInfo({id:t});z(i);const a={unPermissionPackages:[],existDependentsPackages:[]},n=yield k.packageRepository.getManifestByIds(i);if(n.total!==i.length)throw new l.RepoClientError(d.ErrorCode.InvalidBatchUnPublishIds,"unPublish packageIds has no corresponding package.");const s=n.recordList.filter((e=>!!e.groupName&&e.authorId!==r.getId())),c=[...new Set(s.map((e=>e.groupName)))],h=[];for(const e of c)try{yield A.userService.checkIsGroupAdmin(r,e)}catch(t){v.OhpmLazyLogger.error(t),h.push(e)}if(s.filter((e=>h.includes(e.groupName))).forEach((e=>a.unPermissionPackages.push(`${e.name}@${e.version}`))),o.config.allow_remove_depended_packages)return a;const p=[],u=new Set(n.recordList.map((e=>`${e.name}@${e.version}`)));for(const t of n.recordList){const i=t.repoName,r=t.name,o=t.version,n=()=>e(this,void 0,void 0,(function*(){const{total:e,recordList:t}=yield B.unPublishRepository.getDependents(i,r,[o]);if(0===e)return;!!t.find((e=>!u.has(`${e.name}@${e.version}`)))&&a.existDependentsPackages.push(`${r}@${o}`)}));p.push(n())}return yield Promise.all(p),a}))}uploadTgz(t,i,r){return e(this,void 0,void 0,(function*(){const e=i.fileInfo.path;try{const{hspPkg:o,harCache:a}=yield this.getHspPkgInTgz(i,r),n=[],s=[];i.fileInfo=this.changeFileInfo(o.interfaceHar,r,i.fileInfo),s.push(this.genHarMetaData(i,a).then((e=>n.push(e))));const l=Object.assign({},i),d=new R.FileInfo(i.fileInfo);l.fileInfo=this.changeFileInfo(o.hsp,r,d),s.push(this.genHspMetaData(l).then((e=>{n.push(e)}))),yield Promise.all(s);const c=yield this.mergeResult(i.uploadPackageInfo.name,i.uploadPackageInfo.version,n);yield m.publishService.publish(t.getName(),c.name,i.user,c)}finally{yield this.removeUploadCache(e,r)}}))}uploadTgzByStream(t,i,r){return e(this,void 0,void 0,(function*(){const e=i.fileInfo.path;try{const{hspPkg:o,harCache:a}=yield this.getHspPkgInTgz(i,r),n=[],s=[];i.fileInfo=this.changeFileInfo(o.interfaceHar,r,i.fileInfo),s.push(this.genHarMetaDataByStream(i,a).then((e=>n.push(e))));const l=Object.assign({},i),d=new R.FileInfo(i.fileInfo);l.fileInfo=this.changeFileInfo(o.hsp,r,d),s.push(this.genHspMetaDataByStream(l).then((e=>n.push(e)))),yield Promise.all(s);const c=yield this.mergeResult(i.uploadPackageInfo.name,i.uploadPackageInfo.version,n,!0),h={metadata:JSON.stringify(c),pkg_stream:Object.assign(Object.assign({},i.fileInfo),{path:e})};yield y.publishStreamService.publish(t.getName(),c.name,i.user,h)}finally{yield this.removeUploadCache(e,r)}}))}getHspPkgInTgz(t,i){return e(this,void 0,void 0,(function*(){const e=yield C.CommonUtil.hspDetect(t.fileInfo.path);C.CommonUtil.validHspDetectResult(e),U.default.extract({file:t.fileInfo.path,cwd:i,strip:0,sync:!0},[e.interfaceHar,e.hsp]);const r=h.default.resolve(i,e.interfaceHar.split(".")[0]);yield p.FsUtil.createDirIfNotExists(r);const o=h.default.resolve(i,e.hsp.split(".")[0]);return yield p.FsUtil.createDirIfNotExists(o),{hspPkg:e,harCache:r}}))}mergeResult(t,i,r,o){return e(this,void 0,void 0,(function*(){let e=-1,a=-1;if(r.forEach(((t,i)=>{t.name?e=i:a=i})),-1===e||-1===a)throw new l.RepoClientError(d.ErrorCode.MergeMetaDataError,"fail to merge publish result of .har and .hsp!");const n=r[e];if(this.validPackageType(n),n.versions[i].dist.integrity_hsp=r[a].integrity_hsp,n.hspType=r[a].hspType,!o){const e=`${t}-${i}${I.Constants.HSP_SUFFIX}`;n._attachments[e]=r[a]._attachments[e]}return n}))}uploadHar(t,i,r){return e(this,void 0,void 0,(function*(){try{const e=yield this.genHarMetaData(i,r);yield m.publishService.publish(t.getName(),e.name,i.user,e)}finally{yield this.removeUploadCache(i.fileInfo.path,r)}}))}genCacheDir(){return e(this,void 0,void 0,(function*(){let e=h.default.join(I.Constants.DATA_DIR,"./temp/uploads/harball",s.RandomUtil.generateSecureRandomString(4));for(;yield p.FsUtil.exists(e);)e=h.default.join(I.Constants.DATA_DIR,"./temp/uploads/harball",s.RandomUtil.generateSecureRandomString(4));return e}))}isTgzFile(e){return!!e&&e.endsWith(I.Constants.TGZ_SUFFIX)}changeFileInfo(e,t,i){return i.mimetype="application/octet-stream",i.path=h.default.resolve(t,e),i}removeAnalyzeCache(t,i,r,o){return e(this,void 0,void 0,(function*(){try{yield p.FsUtil.rm(r,{recursive:!0,force:!0}),t?yield p.FsUtil.rm(i,{recursive:!0,force:!0}):yield p.FsUtil.rm(o.path,{recursive:!0,force:!0})}catch(e){v.OhpmLazyLogger.warn("fail to delete the temporary file when analyze package.")}}))}removeUploadCache(t,i){return e(this,void 0,void 0,(function*(){try{yield p.FsUtil.rm(t,{recursive:!0,force:!0}),yield p.FsUtil.rm(i,{recursive:!0,force:!0})}catch(e){v.OhpmLazyLogger.warn("fail to delete the temporary file when upload package.")}}))}validPkgField(e,t){if(e.name!==t.name||e.version!==t.version||t.license&&e.license!==t.license)throw new l.RepoClientError(d.ErrorCode.PackageInfoNotMatch,"the HAR package information does not match the request information in name, version and license, please upload it again.");if(t.keywords&&t.keywords.length>0){const i=t.keywords.join(",");if(!e.keywords||e.keywords!==i)throw new l.RepoClientError(d.ErrorCode.PackageInfoNotMatch,"the HAR package information does not match the request information in keyword, please upload it again.")}else if(e.keywords)throw new l.RepoClientError(d.ErrorCode.PackageInfoNotMatch,"the keyword in HAR package information does not match the request information, request keyword information is empty, please upload it again.")}genHarMetaData(t,i){return e(this,void 0,void 0,(function*(){const r=yield function(t,i,r){var o;return e(this,void 0,void 0,(function*(){const e=yield x(t,i,r);let a;try{a=yield p.FsUtil.readFile(t.path)}catch(e){throw new l.RepoClientError(d.ErrorCode.ReadFileError,`Fail to read file ${null!==(o=null==t?void 0:t.path)&&void 0!==o?o:""}, when getting har file data.`,e)}return{mainFest:e,tarballData:a}}))}(t.fileInfo,i,this.validator),o=r.mainFest;return this.validPkgField(t.uploadPackageInfo,o),O(o,r.tarballData)}))}genHarMetaDataByStream(t,i){return e(this,void 0,void 0,(function*(){const e=yield x(t.fileInfo,i,this.validator);this.validPkgField(t.uploadPackageInfo,e);return O(e,yield p.FsUtil.readFile(t.fileInfo.path),!0)}))}genHspMetaData(t){return e(this,void 0,void 0,(function*(){try{yield P.CompressUtil.verifyFileBoom(t.fileInfo.path);const e=yield p.FsUtil.readFile(t.fileInfo.path);return function(e,t){const i={},r=g.ssri.fromData(t);i.integrity_hsp=r.getIntegrity(),i.hspType=I.HSP_TYPE.BUNDLE_APP;const o=`${e.name}-${e.version}.hsp`;return i._attachments={},i._attachments[o]={content_type:"application/octet-stream",data:t.toString("base64"),length:t.length},i}(t.uploadPackageInfo,e)}catch(e){throw new l.RepoClientError(d.ErrorCode.ReadFileError,"Fail to read file, when getting hsp file data.",e)}}))}genHspMetaDataByStream(t){return e(this,void 0,void 0,(function*(){try{const e={},i=yield p.FsUtil.readFile(t.fileInfo.path),r=g.ssri.fromData(i);return e.integrity_hsp=r.getIntegrity(),e.hspType=I.HSP_TYPE.BUNDLE_APP,e}catch(e){throw new l.RepoClientError(d.ErrorCode.ReadFileError,"Fail to read file, when getting hsp file data.",e)}}))}validPackageType(e){if(!e.packageType)throw new l.RepoClientError(d.ErrorCode.InvalidPackagType,"The 'packageType' field is mandatory and cannot be empty!");if(e.packageType!==I.Constants.HSPPackageType)throw new l.RepoClientError(d.ErrorCode.InvalidPackagType,`The 'packageType' invalid! reference value: ${I.Constants.HSPPackageType}`)}filterAgainByVersion(e,t){const i=[],r=t.packageMinVersion,o=t.packageMaxVersion;for(const t of e){const e=t.version;r&&!D.default.gte(e,r)||o&&!D.default.lte(e,o)||i.push(M(t))}return i}getPackageListByFilterWithoutVersion(t){return e(this,void 0,void 0,(function*(){const e=[];let i=1;for(let r=1;r<=i;r++){const o=yield k.packageRepository.getPackageListByFilter(r,1e3,t);e.push(...o.recordList),1===r&&(i=o.total/1e3+1)}return e}))}isVersionValid(e,t){const i=!e||u.VERSION_REGEX.test(e),r=!t||u.VERSION_REGEX.test(t);if(!(i&&r))throw new l.RepoClientError(d.ErrorCode.GetPackageVersionError,`fail to validate "version": "minVersion ${e}" or "MaxVersion ${t}" is valid.`);if(e&&t&&D.default.gte(e,t))throw new l.RepoClientError(d.ErrorCode.GetPackageVersionError,`fail to validate "version": "minVersion" "${e}" is greater than "MaxVersion" "${t}"}.`);return!0}};